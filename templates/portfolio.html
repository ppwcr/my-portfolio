<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Dashboard - NVDR & Short Sales</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script>
        // Debug library loading
        window.addEventListener('load', () => {
        });
    </script>
    <style>
        .loading {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        .sortable {
            cursor: pointer;
            user-select: none;
        }
        
        .table-cell {
            font-variant-numeric: tabular-nums;
        }
        
        .positive {
            color: rgb(22 163 74);
        }
        
        .negative {
            color: rgb(220 38 38);
        }

        /* Make All Symbols table header sticky under the search bar */
        .table-sticky thead th {
            position: sticky;
            top: var(--sticky-offset, 120px); /* computed from search bar height */
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            z-index: 15;
            border-bottom: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        /* Ensure the table container doesn't interfere with sticky positioning */
        .table-sticky {
            position: relative;
        }
        
        /* Make the table container handle overflow properly for sticky headers */
        .table-container {
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
        }

        /* Mini chart styling */
        .chart-mini {
            max-width: 64px;
            max-height: 32px;
            border-radius: 4px;
        }
        
        .chart-mini svg {
            width: 64px;
            height: 32px;
            border-radius: 4px;
        }
        
        /* Date picker styles */
        #portfolio-date-picker.date-unavailable {
            background-color: #f3f4f6;
            color: #9ca3af;
            border-color: #d1d5db;
        }
        
        #portfolio-date-picker.date-available {
            background-color: #ecfdf5;
            border-color: #10b981;
        }
        
        #date-status.available {
            color: #10b981;
        }
        
        #date-status.unavailable {
            color: #ef4444;
        }
        
        #date-status.today {
            color: #3b82f6;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-100 to-slate-200 text-slate-900">
    <div class="max-w-7xl mx-auto p-6 grid gap-6">
        <!-- Header -->
        <header class="flex flex-col md:flex-row md:items-end md:justify-between gap-3">
            <div>
                <h1 class="text-2xl font-bold">Portfolio Dashboard — NVDR & Short Sales</h1>
                <p class="text-sm opacity-70">Symbol • ราคาปิด • NVDR • Short Sales</p>
                <p id="trade-date" class="text-xs opacity-50 mt-1">Loading trade date...</p>
            </div>
            <div class="flex gap-2 items-center">
                <button id="refresh-btn" class="px-3 py-2 rounded-xl shadow bg-white text-sm">
                    Run Fresh Scrape
                </button>
                <button id="export-btn" class="px-3 py-2 rounded-xl shadow bg-white text-sm" title="Export My Portfolio table to CSV">
                    Export My Portfolio CSV
                </button>
                <div class="flex gap-1">
                    <button id="auto-scraper-start-btn" class="px-3 py-2 rounded-xl shadow bg-green-100 text-green-700 text-sm">
                        Start Auto-Scrape
                    </button>
                    <button id="auto-scraper-stop-btn" class="px-3 py-2 rounded-xl shadow bg-red-100 text-red-700 text-sm hidden">
                        Stop Auto-Scrape
                    </button>
                </div>
            </div>
        </header>

        

        <!-- Status Bar -->
        <section id="status-bar" class="bg-gradient-to-r from-blue-50 to-green-50 border border-blue-200 rounded-xl p-3">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <div id="status-icon" class="text-lg">📊</div>
                    <div>
                        <div id="status-message" class="text-sm font-medium">Database ready</div>
                        <div id="status-details" class="text-xs opacity-70"></div>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <div id="status-timestamp" class="text-xs opacity-60"></div>
                </div>
            </div>
        </section>

        <!-- Data Timestamps Section -->
        <section id="data-timestamps" class="bg-white/80 rounded-2xl shadow p-4">
            <div class="flex items-center justify-between mb-3">
                <h2 class="text-lg font-semibold">📅 Data Source Timestamps</h2>
                <button id="refresh-timestamps-btn" class="px-3 py-1 rounded-lg shadow bg-blue-100 text-blue-700 text-sm">
                    Refresh
                </button>
            </div>
            <div id="timestamps-content" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                <div class="text-center text-sm text-gray-500">Loading timestamps...</div>
            </div>
        </section>

        <!-- Database Update Status -->
        <section id="db-progress" class="bg-white/80 rounded-2xl shadow p-4 hidden">
            <div class="flex items-center gap-2 mb-2">
                <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500"></div>
                <h2 class="text-sm font-semibold">Database Update</h2>
            </div>
            <div id="db-progress-message" class="text-sm text-gray-700">Starting…</div>
            <div id="db-progress-details" class="text-xs text-gray-500 mt-1"></div>
        </section>

        <!-- SET Index Table + Chart (side by side) -->
        <section class="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <!-- Left: existing SET Index table card -->
            <div class="bg-white/80 rounded-2xl shadow">
                <div class="p-4 border-b">
                    <div class="flex items-center justify-between">
                        <h2 class="text-lg font-semibold">SET Index</h2>
                        <div class="flex gap-2 items-center">
                            <span id="set-index-timestamp" class="text-xs opacity-60">Loading...</span>
                            <button id="refresh-index-btn" class="px-3 py-1 rounded-lg shadow bg-blue-100 text-blue-700 text-sm">
                                Refresh
                            </button>
                        </div>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b bg-white/70">
                                <th class="py-2 px-3 text-left">Index</th>
                                <th class="py-2 px-3 text-right">Last</th>
                                <th class="py-2 px-3 text-right">Change</th>
                                <th class="py-2 px-3 text-right">Volume ('000 Shares)</th>
                                <th class="py-2 px-3 text-right">Value (M.Baht)</th>
                            </tr>
                        </thead>
                        <tbody id="set-index-tbody">
                            <!-- SET index data will be populated here -->
                        </tbody>
                    </table>
                    
                    <!-- Loading state for SET Index -->
                    <div id="set-index-loading" class="py-8 text-center text-slate-500">
                        <div class="loading">Loading SET index data...</div>
                    </div>
                    
                    <!-- Empty state for SET Index -->
                    <div id="set-index-empty" class="py-8 text-center text-slate-500" style="display: none;">
                        <div class="mb-2">📊</div>
                        <div>No SET index data available</div>
                        <div class="text-xs mt-1">Please check your connection and try refreshing</div>
                    </div>
                </div>
            </div>

            <!-- Right: Lightweight Charts (SET) -->
            <div class="bg-white/80 rounded-2xl shadow p-2">
                <div class="flex items-center justify-between px-2 pt-1">
                    <h2 class="text-sm font-semibold">SET Index — Daily</h2>
                    <span id="set-latest-meta" class="text-xs opacity-60">Loading…</span>
                </div>
                <div id="setChart" class="w-full h-[420px] md:h-[520px]"></div>
            </div>
        </section>

        <!-- Summary Cards -->
        <section id="summary-cards" class="grid sm:grid-cols-2 lg:grid-cols-4 gap-3">
            <!-- Cards will be populated by JavaScript -->
        </section>

        <!-- Investor Summary Table -->
        <section id="investor-section" class="bg-white/80 rounded-2xl shadow p-4" style="display: none;">
            <h2 class="text-lg font-semibold mb-3">Investor Summary - Latest Trade Date</h2>
            <div class="overflow-x-auto">
                <table class="w-full text-xs">
                    <thead>
                        <tr class="border-b bg-white/70">
                            <th rowspan="2" class="py-2 px-2 text-left border-r">Investor Type</th>
                            <th colspan="5" class="py-1 px-2 text-center border-r bg-blue-50">Daily (Latest Trade Date)</th>
                            <th colspan="5" class="py-1 px-2 text-center border-r bg-green-50">Month-to-Date</th>
                            <th colspan="5" class="py-1 px-2 text-center bg-orange-50">Year-to-Date</th>
                        </tr>
                        <tr class="border-b bg-white/70 text-xs">
                            <th class="py-1 px-1 text-right">Buy (MB)</th>
                            <th class="py-1 px-1 text-right">%</th>
                            <th class="py-1 px-1 text-right">Sell (MB)</th>
                            <th class="py-1 px-1 text-right">%</th>
                            <th class="py-1 px-1 text-right border-r">Net (MB)</th>
                            <th class="py-1 px-1 text-right">Buy (MB)</th>
                            <th class="py-1 px-1 text-right">%</th>
                            <th class="py-1 px-1 text-right">Sell (MB)</th>
                            <th class="py-1 px-1 text-right">%</th>
                            <th class="py-1 px-1 text-right border-r">Net (MB)</th>
                            <th class="py-1 px-1 text-right">Buy (MB)</th>
                            <th class="py-1 px-1 text-right">%</th>
                            <th class="py-1 px-1 text-right">Sell (MB)</th>
                            <th class="py-1 px-1 text-right">%</th>
                            <th class="py-1 px-1 text-right">Net (MB)</th>
                        </tr>
                    </thead>
                    <tbody id="investor-tbody">
                        <!-- Investor data will be populated here -->
                    </tbody>
                </table>
            </div>
        </section>

        <!-- My Portfolio Table -->
        <section class="bg-white/80 rounded-2xl shadow">
            <div class="p-4 border-b">
                <div class="flex items-center justify-between">
                    <div>
                        <h2 class="text-lg font-semibold">My Portfolio</h2>
                        <p id="portfolio-data-info" class="text-xs opacity-60 mt-1"></p>
                    </div>
                    <div class="flex gap-2 items-center">
                        <div class="flex items-center gap-2 relative">
                            <label for="portfolio-date-picker" class="text-sm opacity-70">Date:</label>
                            <input type="date" 
                                   id="portfolio-date-picker" 
                                   class="px-2 py-1 rounded border text-sm bg-white focus:outline-none focus:ring-2 focus:ring-blue-300" 
                                   title="Select date to view portfolio holdings">
                            <div id="date-status" class="text-xs opacity-60 ml-1"></div>
                        </div>
                        <button id="edit-mode-toggle" class="px-3 py-1 rounded-lg shadow text-sm border" onclick="toggleEditMode()">
                            <span id="edit-mode-text">✏️ Edit Mode</span>
                        </button>
                        <button id="save-portfolio-btn" class="px-3 py-1 rounded-lg shadow text-sm border bg-green-100 text-green-700 hidden" onclick="saveAllChanges()">
                            <span id="save-portfolio-text">💾 Save Changes</span>
                        </button>
                        <span id="portfolio-count" class="text-sm opacity-70">0 symbols</span>
                        <button id="refresh-portfolio-btn" class="px-3 py-1 rounded-lg shadow bg-blue-100 text-blue-700 text-sm">
                            Refresh
                        </button>
                    </div>
                </div>
            </div>
            <div class="overflow-x-auto">
                <table class="w-full text-sm">
                    <thead>
                        <tr class="border-b bg-white/70">
                            <th class="py-2 px-3 text-center">No.</th>
                            <th class="py-2 px-3 text-left">Symbol</th>
                            <th class="py-2 px-3 text-right">Quantity</th>
                            <th class="py-2 px-3 text-right">Avg Cost Price</th>
                            <th class="py-2 px-3 text-right">Cost</th>
                            <th class="py-2 px-3 text-right">Change</th>
                            <th class="py-2 px-3 text-right">ราคาปิด</th>
                            <th class="py-2 px-3 text-right">% Change</th>
                            <th class="py-2 px-3 text-right">P/L</th>
                            <th class="py-2 px-3 text-right">%P/L</th>
                            <th class="py-2 px-3 text-right">NVDR (Baht)</th>
                            <th class="py-2 px-3 text-right">Short Sales (Baht)</th>
                            <th class="py-2 px-3 text-center">Chart</th>
                            <th class="py-2 px-3 text-center">Action</th>
                        </tr>
                    </thead>
                    <tbody id="my-portfolio-tbody">
                        <!-- My portfolio data will be populated here -->
                    </tbody>
                </table>
                
                <!-- Loading state for My Portfolio -->
                <div id="my-portfolio-loading" class="py-12 text-center text-slate-500" style="display: none;">
                    <div class="mb-2">⏳</div>
                    <div>Loading portfolio data...</div>
                    <div class="text-xs mt-1">Please wait while we fetch data for the selected date</div>
                </div>
                
                <!-- Empty state for My Portfolio -->
                <div id="my-portfolio-empty" class="py-12 text-center text-slate-500">
                    <div class="mb-2">📋</div>
                    <div>Your portfolio is empty</div>
                    <div class="text-xs mt-1">Click "+" next to any symbol below to add it to your portfolio</div>
                </div>
            </div>
        </section>

        <!-- Search Bar (for All Symbols) with Column Headers -->
        <section id="all-symbols-search" class="all-symbols sticky top-2 z-10 bg-white/90 backdrop-blur rounded-t-2xl border border-blue-200 shadow mt-2">
            <style>
                /* Equal column widths for perfect header-content alignment */
                .all-symbols {
                    --col-width: 12.5%; /* 8 columns = 12.5% each */
                }
                
                .all-symbols .header-col {
                    width: var(--col-width) !important;
                    flex: 0 0 var(--col-width) !important;
                }
                
                .all-symbols table {
                    table-layout: fixed !important;
                    width: 100% !important;
                }
                
                .all-symbols col {
                    width: var(--col-width) !important;
                }
                
                .all-symbols td {
                    width: var(--col-width) !important;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
                .table-container { scrollbar-gutter: stable both-edges; }
            </style>
            <div class="p-3 border-b border-blue-200">
                <div class="flex items-center justify-between gap-3 mb-2">
                    <h2 class="text-sm font-semibold">All Symbols</h2>
                    <div id="all-symbols-header" class="text-xs text-slate-600">Loading…</div>
                </div>
                <div class="flex items-center gap-3">
                    <div class="relative w-full md:max-w-2xl">
                        <span class="absolute left-3 top-1/2 -translate-y-1/2 text-blue-600">🔎</span>
                        <input
                            id="search-input"
                            placeholder="Search all symbols (e.g., AOT)"
                            class="w-full pl-10 pr-10 py-3 rounded-xl border border-blue-300 bg-white shadow-inner text-base focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                        <button id="search-clear" title="Clear"
                                class="absolute right-2 top-1/2 -translate-y-1/2 px-2 py-1 rounded hover:bg-slate-100 text-slate-500 hidden">✕</button>
                    </div>
                    <span id="search-count" class="text-xs md:text-sm text-slate-600 whitespace-nowrap"></span>
                </div>
            </div>
            <!-- Column Headers integrated into search bar -->
            <div class="bg-white/70 border-b border-slate-200">
                <div class="flex items-center text-sm font-medium text-slate-700">
                    <div class="header-col py-2 px-3 text-left sortable cursor-pointer whitespace-nowrap" data-key="symbol">
                        <span class="inline-flex items-center gap-1">
                            Symbol
                            <span class="text-xs opacity-30" id="sort-symbol">↕</span>
                        </span>
                    </div>
                    <div class="header-col py-2 px-3 text-left whitespace-nowrap">Sector</div>
                    <div class="header-col py-2 px-3 text-right sortable cursor-pointer whitespace-nowrap" data-key="change">
                        <span class="inline-flex items-center gap-1 justify-end">
                            Change
                            <span class="text-xs opacity-30" id="sort-change">↕</span>
                        </span>
                    </div>
                    <div class="header-col py-2 px-3 text-right sortable cursor-pointer whitespace-nowrap" data-key="close">
                        <span class="inline-flex items-center gap-1 justify-end">
                            ราคาปิด
                            <span class="text-xs opacity-30" id="sort-close">↕</span>
                        </span>
                    </div>
                    <div class="header-col py-2 px-3 text-right sortable cursor-pointer whitespace-nowrap" data-key="pct_change">
                        <span class="inline-flex items-center gap-1 justify-end">
                            % Change
                            <span class="text-xs opacity-30" id="sort-pct_change">↕</span>
                        </span>
                    </div>
                    <div class="header-col py-2 px-3 text-right sortable cursor-pointer whitespace-nowrap" data-key="nvdr_baht">
                        <span class="inline-flex items-center gap-1 justify-end">
                            NVDR (Baht)
                            <span class="text-xs opacity-30" id="sort-nvdr_baht">↕</span>
                        </span>
                    </div>
                    <div class="header-col py-2 px-3 text-right sortable cursor-pointer whitespace-nowrap" data-key="shortBaht">
                        <span class="inline-flex items-center gap-1 justify-end">
                            Short Sales (Baht)
                            <span class="text-xs opacity-30" id="sort-shortBaht">↕</span>
                        </span>
                    </div>
                    <div class="header-col py-2 px-3 text-center whitespace-nowrap">Portfolio</div>
                </div>
            </div>
        </section>

        <!-- Main Portfolio Table -->
        <div class="table-container all-symbols overflow-x-auto rounded-b-2xl shadow bg-white/80">
            <table class="w-full text-sm table-fixed">
                <colgroup>
                    <col class="content-col" />
                    <col class="content-col" />
                    <col class="content-col" />
                    <col class="content-col" />
                    <col class="content-col" />
                    <col class="content-col" />
                    <col class="content-col" />
                    <col class="content-col" />
                </colgroup>
                <tbody id="portfolio-tbody">
                    <!-- Portfolio data will be populated here -->
                </tbody>
            </table>
            
            <!-- Loading state -->
            <div id="loading-state" class="py-12 text-center text-slate-500">
                <div class="loading">Loading portfolio data...</div>
            </div>
            
            <!-- Empty state -->
            <div id="empty-state" class="py-12 text-center text-slate-500" style="display: none;">
                No portfolio data available. Please check your database connection.
            </div>
        </div>

        <footer class="text-[11px] opacity-60">
            Real-time data from SET database. Last updated: <span id="last-updated">Loading...</span>
        </footer>
    </div>

    <script>
        // Global state
        let portfolioData = [];
        let originalData = [];
        let myPortfolioData = [];
        let portfolioSymbols = new Set();
        let sortKey = 'symbol';
        let sortDir = 'asc';
        let searchQuery = '';
        let currentPortfolioDate = new Date().toISOString().split('T')[0]; // Today as default
        let editMode = {}; // Track which cells are in edit mode
        let isEditModeEnabled = false; // Global edit mode toggle
        
        // Chart management
        // Removed caching system to avoid issues

        // Utility functions
        function fmt(n, frac = 2) {
            if (n == null || !Number.isFinite(n)) return '';
            return n.toLocaleString(undefined, { maximumFractionDigits: frac });
        }

        function fmtPct(n, frac = 2) {
            if (n == null || !Number.isFinite(n)) return '';
            return `${n.toFixed(frac)}%`;
        }


        function formatNumber(value, millions = false) {
            if (value === null || value === undefined || isNaN(value)) return '';
            if (millions && Math.abs(value) >= 1) {
                return fmt(value, 2);
            }
            return fmt(value, 2);
        }

        function getValueClass(value) {
            if (value > 0) return 'positive';
            if (value < 0) return 'negative';
            return '';
        }

        // Status bar functions
        function showStatus(icon, message, details = '', type = 'info') {
            const statusBar = document.getElementById('status-bar');
            const statusIcon = document.getElementById('status-icon');
            const statusMessage = document.getElementById('status-message');
            const statusDetails = document.getElementById('status-details');
            const statusTimestamp = document.getElementById('status-timestamp');
            
            statusIcon.textContent = icon;
            statusMessage.textContent = message;
            statusDetails.textContent = details;
            statusTimestamp.textContent = new Date().toLocaleTimeString();
            
            // Update styling based on type
            statusBar.className = `rounded-xl p-3 border ${
                type === 'success' ? 'bg-gradient-to-r from-green-50 to-blue-50 border-green-200' :
                type === 'warning' ? 'bg-gradient-to-r from-yellow-50 to-orange-50 border-yellow-200' :
                type === 'error' ? 'bg-gradient-to-r from-red-50 to-pink-50 border-red-200' :
                'bg-gradient-to-r from-blue-50 to-green-50 border-blue-200'
            }`;
            
            statusBar.classList.remove('hidden');
        }
        
        function hideStatus() {
            // Reset status to default instead of hiding the entire bar
            const statusIcon = document.getElementById('status-icon');
            const statusMessage = document.getElementById('status-message');
            const statusDetails = document.getElementById('status-details');
            
            statusIcon.textContent = '📊';
            statusMessage.textContent = 'Database ready';
            statusDetails.textContent = '';
        }
        
        function autoHideStatus(delay = 5000) {
            setTimeout(hideStatus, delay);
        }

        // Weekend check function
        function isWeekend() {
            const today = new Date();
            const day = today.getDay();
            return day === 0 || day === 6; // Sunday = 0, Saturday = 6
        }

        // Progress monitoring for scraping
        let progressEventSource = null;
        
        function startProgressMonitoring() {
            if (progressEventSource) {
                progressEventSource.close();
            }
            
            progressEventSource = new EventSource('/api/progress');
            
            progressEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateScrapingStatus(data);
                } catch (e) {
                    console.error('Error parsing progress data:', e);
                }
            };
            
            progressEventSource.onerror = function(event) {
                console.error('Progress monitoring error:', event);
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
            };
        }
        
        function showDatabaseUpdateStatus(progressData) {
            const { status, step, progress, message, details } = progressData;
            
            if (status === 'completed') {
                if (step === 'partial') {
                    showStatus('⚠️', 'Database update - Partial Success', message, 'warning');
                    // Do NOT auto-hide for partial success - keep warning visible until next update
                } else {
                    showStatus('✅', 'Database update completed', message, 'success');
                    autoHideStatus(5000);
                }
                return;
            }
            
            if (status === 'error') {
                showStatus('❌', 'Database update failed', message, 'error');
                // Do NOT auto-hide for errors - keep error visible until next update
                return;
            }
            
            // Map different database update steps to user-friendly messages
            let statusIcon = '🔄';
            let statusMessage = message || 'Updating database...';
            let statusDetails = '';
            
            if (step === 'Initializing' || message.includes('Starting')) {
                statusIcon = '🚀';
                statusMessage = 'Starting database update...';
            } else if (step === 'Scraping' || message.includes('scraping')) {
                statusIcon = '📊';
                statusMessage = 'Scraping market data...';
                statusDetails = details || '';
            } else if (step === 'Saving' || message.includes('Saving')) {
                statusIcon = '💾';
                statusMessage = 'Saving to database...';
                statusDetails = details || '';
            } else if (step === 'Processing' || message.includes('Processing')) {
                statusIcon = '⚙️';
                statusMessage = 'Processing data...';
                statusDetails = details || '';
            }
            
            showStatus(statusIcon, statusMessage, statusDetails, 'info');
        }

        function updateScrapingStatus(progressData) {
            const { status, step, progress, message, details } = progressData;
            
            if (status === 'completed') {
                showStatus('✅', 'Data scraping completed', message, 'success');
                autoHideStatus(5000);
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
                return;
            }
            
            if (status === 'error') {
                showStatus('❌', 'Scraping failed', message, 'error');
                autoHideStatus(10000);
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
                return;
            }
            
            // Extract icon from message if present, otherwise use default mapping
            let statusIcon = '🔄';
            let statusMessage = message || 'Processing...';
            let statusDetails = `${progress}% complete`;
            
            // Extract emoji from the beginning of the message if present
            const emojiMatch = message.match(/^([\u{1F000}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]+)/u);
            if (emojiMatch) {
                statusIcon = emojiMatch[1];
                statusMessage = message.substring(emojiMatch[1].length).trim();
            }
            
            // Add detailed information from details object if available
            if (details) {
                if (details.current_sector) {
                    statusDetails = `${details.current_sector} sector (${details.completed || 0}/${details.total || 8})`;
                } else if (details.total_records) {
                    statusDetails = `${details.total_records} records processed`;
                } else if (details.records_count) {
                    statusDetails = `${details.records_count} records saved`;
                } else if (details.summary) {
                    statusDetails = details.summary;
                } else {
                    statusDetails = `${progress}% complete`;
                }
            }
            
            showStatus(statusIcon, statusMessage, statusDetails, 'info');
        }

        // Auto database update function
        async function autoUpdateDatabase(silent = false, forceRefresh = false) {
            if (!silent) {
                showStatus('🔄', 'Starting database update...', 'Updating market data', 'info');
            }
            
            try {
                // Use full refresh endpoint if forceRefresh is true (for initial page load with no data)
                const endpoint = forceRefresh ? '/api/save-to-database-full' : '/api/auto-update-database';
                const response = await fetch(endpoint, { method: 'POST' });
                const result = await response.json();
                
                if (result.success) {
                    if (result.updated) {
                        if (!silent) {
                            // Start monitoring progress for the scraping operation
                            startProgressMonitoring();
                            showStatus('🚀', 'Starting data collection...', 'Scraping fresh market data', 'info');
                        } else {
                            // Silent mode: just show a subtle indicator
                            console.log('Background database update started...');
                            // Add a small indicator in the timestamp area
                            const timestampEl = document.getElementById('status-timestamp');
                            if (timestampEl) {
                                timestampEl.textContent = '🔄 Updating...';
                                timestampEl.style.color = '#3b82f6';
                            }
                        }
                    } else {
                        if (!silent) {
                            showStatus('✅', 'Database is up to date', result.message, 'success');
                            autoHideStatus();
                        }
                    }
                } else {
                    // Always show warnings/errors even in silent mode
                    showStatus('⚠️', 'Database update completed with warnings', result.message, 'warning');
                }
            } catch (error) {
                console.error('Auto-update error:', error);
                // Always show errors even in silent mode
                showStatus('❌', 'Database update failed', `Error: ${error.message}`, 'error');
            }
        }

        // API functions
        async function fetchDashboardData(tradeDate = null, showAllSymbols = false) {
            try {
                let url = `/api/portfolio/dashboard?_t=${Date.now()}`;
                if (tradeDate) {
                    url += `&trade_date=${tradeDate}`;
                }
                if (showAllSymbols) {
                    url += `&show_all_symbols=true`;
                }
                const response = await fetch(url);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching dashboard data:', error);
                return null;
            }
        }

        async function fetchSetIndexData() {
            try {
                const response = await fetch('/api/set-index');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching SET index data:', error);
                return null;
            }
        }

        async function fetchDataTimestamps() {
            try {
                const response = await fetch('/api/data/timestamps');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching data timestamps:', error);
                return null;
            }
        }

        async function fetchSummaryData(dashboardData) {
            // Use the dedicated summary API endpoint that has proper fallback logic
            try {
                const response = await fetch('/api/portfolio/summary', {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Summary API returned ${response.status}`);
                }
                
                const summaryData = await response.json();
                console.log(`📊 Summary from API: ${summaryData.total_symbols} symbols, NVDR: ${summaryData.total_nvdr_mb}M, Short: ${summaryData.total_short_mb}M`);
                
                return summaryData;
            } catch (error) {
                console.error('Error fetching summary data:', error);
                
                // Fallback to calculating from dashboard data if API fails
                if (dashboardData && dashboardData.portfolio_stocks) {
                    try {
                        const stocks = dashboardData.portfolio_stocks;
                        const totalSymbols = stocks.length;
                        const totalNvdr = stocks.reduce((sum, stock) => sum + (stock.nvdr || 0), 0);
                        const totalShort = stocks.reduce((sum, stock) => sum + (stock.shortBaht || 0), 0);
                        const validPrices = stocks.map(s => s.close).filter(price => price > 0);
                        const avgPrice = validPrices.length > 0 ? 
                            validPrices.reduce((sum, price) => sum + price, 0) / validPrices.length : 0;
                        
                        console.log(`📊 Summary fallback: ${totalSymbols} stocks, NVDR: ${(totalNvdr/1000000).toFixed(1)}M, Short: ${(totalShort/1000000).toFixed(1)}M`);
                        
                        return {
                            trade_date: dashboardData.trade_date,
                            total_symbols: totalSymbols,
                            avg_price: parseFloat(avgPrice.toFixed(2)),
                            total_nvdr_mb: parseFloat((totalNvdr / 1000000).toFixed(2)),
                            total_short_mb: parseFloat((totalShort / 1000000).toFixed(2))
                        };
                    } catch (fallbackError) {
                        console.error('Error in summary fallback calculation:', fallbackError);
                        return null;
                    }
                }
                
                return null;
            }
        }

        async function fetchMyPortfolio() {
            try {
                const response = await fetch('/api/portfolio/my-symbols');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching my portfolio:', error);
                return null;
            }
        }

        async function addToPortfolio(symbol) {
            try {
                const response = await fetch('/api/portfolio/add-symbol', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol })
                });
                const result = await response.json();
                if (result.success) {
                    portfolioSymbols.add(symbol);
                    
                    // Only refresh portfolio data, don't reload all charts
                    const portfolioData = await fetchMyPortfolio();
                    if (portfolioData) {
                        myPortfolioData = portfolioData.portfolio_stocks || [];
                        portfolioSymbols = new Set(portfolioData.portfolio_symbols || []);
                        // Only render the portfolio table, charts will be handled by renderMyPortfolio
                        renderMyPortfolio(myPortfolioData);
                    }
                }
                return result;
            } catch (error) {
                console.error('Error adding to portfolio:', error);
                return { success: false, error: error.message };
            }
        }

        async function removeFromPortfolio(symbol) {
            try {
                const response = await fetch(`/api/portfolio/remove-symbol/${symbol}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    // Show alert for validation errors (like cannot remove symbol with holdings)
                    alert(`Cannot remove ${symbol}: ${errorData.detail || 'Unknown error'}`);
                    return { success: false, error: errorData.detail };
                }
                
                const result = await response.json();
                if (result.success) {
                    portfolioSymbols.delete(symbol);
                    
                    // Remove chart completely
                    removeChart(symbol);
                    
                    // Only refresh portfolio data, don't reload all charts
                    const portfolioData = await fetchMyPortfolio();
                    if (portfolioData) {
                        myPortfolioData = portfolioData.portfolio_stocks || [];
                        portfolioSymbols = new Set(portfolioData.portfolio_symbols || []);
                        // Only render the portfolio table, charts will be handled by renderMyPortfolio
                        renderMyPortfolio(myPortfolioData);
                    }
                    
                    // Show success message
                    alert(`Successfully removed ${symbol} from portfolio`);
                }
                return result;
            } catch (error) {
                console.error('Error removing from portfolio:', error);
                alert(`Error removing ${symbol}: ${error.message}`);
                return { success: false, error: error.message };
            }
        }

        async function refreshMyPortfolio() {
            // Use the current selected date
            await loadPortfolioForDate(currentPortfolioDate);
        }
        
        async function refreshPortfolioWithLatestPrices() {
            console.log('🔄 Refreshing portfolio with latest prices...');
            
            // Show loading state
            const refreshBtn = document.getElementById('refresh-portfolio-btn');
            if (refreshBtn) {
                const originalText = refreshBtn.textContent;
                refreshBtn.disabled = true;
                refreshBtn.textContent = 'Refreshing...';
                
                try {
                    // Refresh portfolio data for current date
                    await loadPortfolioForDate(currentPortfolioDate);
                    console.log('✅ Portfolio refreshed with latest prices');
                } catch (error) {
                    console.error('❌ Error refreshing portfolio:', error);
                } finally {
                    // Restore button
                    refreshBtn.disabled = false;
                    refreshBtn.textContent = originalText;
                }
            }
        }
        
        // Remove chart for a specific symbol (simple cleanup)
        function removeChart(symbol) {
            // Remove chart elements from DOM
            const chartElement = document.getElementById(`chart-${symbol}`);
            const loadingElement = document.getElementById(`loading-${symbol}`);
            
            if (chartElement) {
                chartElement.remove();
            }
            if (loadingElement) {
                loadingElement.remove();
            }
            
        }

        // Render functions
        function renderSetIndex(indexData) {
            const tbody = document.getElementById('set-index-tbody');
            const loadingState = document.getElementById('set-index-loading');
            const emptyState = document.getElementById('set-index-empty');
            const timestampEl = document.getElementById('set-index-timestamp');

            loadingState.style.display = 'none';

            if (!indexData || !indexData.success || !indexData.data || indexData.data.length === 0) {
                emptyState.style.display = 'block';
                tbody.innerHTML = '';
                timestampEl.textContent = indexData?.error || 'Failed to load data';
                return;
            }

            emptyState.style.display = 'none';
            timestampEl.textContent = indexData.timestamp || 'Unknown time';

            tbody.innerHTML = indexData.data.map(item => {
                const changeValue = parseFloat(item.change.replace(/[^-+\d.]/g, ''));
                const changeClass = getValueClass(changeValue);
                
                return `
                <tr class="border-b last:border-b-0 hover:bg-slate-50">
                    <td class="py-2 px-3 font-medium">${item.index || ''}</td>
                    <td class="py-2 px-3 text-right table-cell">${item.last || ''}</td>
                    <td class="py-2 px-3 text-right table-cell ${changeClass}">${item.change || ''}</td>
                    <td class="py-2 px-3 text-right table-cell">${item.volume && item.volume !== '-' ? formatNumber(parseFloat(item.volume), 0) : '-'}</td>
                    <td class="py-2 px-3 text-right table-cell">${item.value || ''}</td>
                </tr>
                `;
            }).join('');
        }

        function renderSummaryCards(summaryData) {
            const container = document.getElementById('summary-cards');
            if (!summaryData || summaryData.error) {
                container.innerHTML = '<div class="col-span-4 text-center text-slate-500">No summary data available</div>';
                return;
            }

            container.innerHTML = `
                <div class="rounded-2xl bg-white/80 p-4 shadow">
                    <div class="text-xs opacity-60">Total Symbols</div>
                    <div class="text-xl font-semibold table-cell">${summaryData.total_symbols || 0}</div>
                    <div class="text-xs opacity-50">stocks</div>
                </div>
                <div class="rounded-2xl bg-white/80 p-4 shadow">
                    <div class="text-xs opacity-60">Avg Price</div>
                    <div class="text-xl font-semibold table-cell">${formatNumber(summaryData.avg_price)}</div>
                    <div class="text-xs opacity-50">Baht</div>
                </div>
                <div class="rounded-2xl bg-white/80 p-4 shadow">
                    <div class="text-xs opacity-60">NVDR (Σ)</div>
                    <div class="text-xl font-semibold table-cell ${getValueClass(summaryData.total_nvdr_mb)}">${formatNumber(summaryData.total_nvdr_mb, true)}</div>
                    <div class="text-xs opacity-50">M.Baht</div>
                </div>
                <div class="rounded-2xl bg-white/80 p-4 shadow">
                    <div class="text-xs opacity-60">Short Sales (Σ)</div>
                    <div class="text-xl font-semibold table-cell ${getValueClass(-summaryData.total_short_mb)}">${formatNumber(summaryData.total_short_mb, true)}</div>
                    <div class="text-xs opacity-50">M.Baht</div>
                </div>
            `;
        }

        function renderDataTimestamps(timestampsData) {
            const container = document.getElementById('timestamps-content');
            if (!timestampsData || !timestampsData.success || !timestampsData.timestamps) {
                container.innerHTML = '<div class="col-span-full text-center text-sm text-gray-500">Failed to load timestamps</div>';
                return;
            }

            const timestamps = timestampsData.timestamps;
            const lastUpdated = timestampsData.last_updated;

            // Define display names and icons for each data source
            const sourceConfig = {
                'sector_data': { name: 'Sector Data', icon: '📊', color: 'blue' },
                'investor_summary': { name: 'Investor Summary', icon: '👥', color: 'green' },
                'nvdr_trading': { name: 'NVDR Trading', icon: '💼', color: 'purple' },
                'short_sales_trading': { name: 'Short Sales', icon: '📉', color: 'red' },
                'set_index': { name: 'SET Index', icon: '📈', color: 'orange' }
            };

            container.innerHTML = Object.entries(timestamps).map(([source, info]) => {
                const config = sourceConfig[source] || { name: source, icon: '📋', color: 'gray' };
                const tradeDate = info.latest_trade_date || 'N/A';
                const recordCount = info.record_count || 0;
                const updatedAt = info.updated_at ? new Date(info.updated_at).toLocaleString() : 'N/A';
                const status = info.status || 'unknown';

                return `
                    <div class="bg-gradient-to-br from-${config.color}-50 to-${config.color}-100 border border-${config.color}-200 rounded-xl p-3">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-lg">${config.icon}</span>
                            <h3 class="font-semibold text-sm">${config.name}</h3>
                        </div>
                        <div class="space-y-1 text-xs">
                            <div class="flex justify-between">
                                <span class="opacity-70">Trade Date:</span>
                                <span class="font-medium">${tradeDate}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="opacity-70">Records:</span>
                                <span class="font-medium">${recordCount.toLocaleString()}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="opacity-70">Status:</span>
                                <span class="font-medium ${status === 'active' ? 'text-green-600' : 'text-yellow-600'}">${status}</span>
                            </div>
                            <div class="text-xs opacity-60 mt-2 pt-2 border-t border-${config.color}-200">
                                Updated: ${updatedAt}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Update the last updated timestamp
            if (lastUpdated) {
                const lastUpdatedEl = document.getElementById('status-timestamp');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = `Last updated: ${new Date(lastUpdated).toLocaleString()}`;
                }
            }
        }

        function renderInvestorSummary(investorData, dateDates) {
            const section = document.getElementById('investor-section');
            const tbody = document.getElementById('investor-tbody');

            if (!investorData || investorData.length === 0) {
                section.style.display = 'none';
                return;
            }

            // Update header titles with actual dates if available
            if (dateDates && dateDates.investor) {
                const headerTitle = section.querySelector('h2');
                if (headerTitle) {
                    headerTitle.textContent = `Investor Summary - ${dateDates.investor}`;
                }
                
                const dailyHeader = section.querySelector('th[colspan="5"].bg-blue-50');
                if (dailyHeader) {
                    dailyHeader.textContent = `Daily (${dateDates.investor})`;
                }
            }

            // Group by investor type (in case there are duplicates, take the latest)
            const groupedData = {};
            investorData.forEach(item => {
                groupedData[item.investor_type] = item;
            });

            section.style.display = 'block';
            tbody.innerHTML = Object.values(groupedData).map(investor => `
                <tr class="border-b last:border-b-0 hover:bg-slate-50">
                    <td class="py-2 px-2 font-medium text-sm border-r">${investor.investor_type || ''}</td>
                    
                    <!-- Period 1 -->
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period1_buy_value, true)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period1_buy_percent)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period1_sell_value, true)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period1_sell_percent)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs border-r ${getValueClass(investor.period1_net_value)}">${formatNumber(investor.period1_net_value, true)}</td>
                    
                    <!-- Period 2 -->
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period2_buy_value, true)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period2_buy_percent)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period2_sell_value, true)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period2_sell_percent)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs border-r ${getValueClass(investor.period2_net_value)}">${formatNumber(investor.period2_net_value, true)}</td>
                    
                    <!-- Period 3 -->
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period3_buy_value, true)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period3_buy_percent)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period3_sell_value, true)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs">${formatNumber(investor.period3_sell_percent)}</td>
                    <td class="py-1 px-1 text-right table-cell text-xs ${getValueClass(investor.period3_net_value)}">${formatNumber(investor.period3_net_value, true)}</td>
                </tr>
            `).join('');
        }

        function renderMyPortfolio(data) {
            const tbody = document.getElementById('my-portfolio-tbody');
            const emptyState = document.getElementById('my-portfolio-empty');
            const loadingState = document.getElementById('my-portfolio-loading');
            const countEl = document.getElementById('portfolio-count');

            // Hide loading state when data is rendered
            loadingState.style.display = 'none';
            
            countEl.textContent = `${data.length} symbols`;

            if (!data || data.length === 0) {
                emptyState.style.display = 'block';
                tbody.innerHTML = '';
                return;
            }

            // Sort data alphabetically by symbol A-Z (as backup to database sort)
            const sortedData = [...data].sort((a, b) => a.symbol.localeCompare(b.symbol));

            emptyState.style.display = 'none';
            
            // Calculate totals for the summary row
            let totalCost = 0;
            let totalPLAmount = 0;
            let totalPLPercent = 0;
            let totalQuantity = 0;
            
            // First, render all the data rows and calculate totals
            const dataRows = sortedData.map((stock, index) => {
                const rowNumber = index + 1;
                const quantity = stock.quantity || 0;
                const avgCostPrice = stock.avg_cost_price || 0;
                const cost = quantity * avgCostPrice;
                // Calculate P/L dynamically
                const closePrice = stock.close || 0;
                const plAmount = quantity > 0 && avgCostPrice > 0 ? (closePrice - avgCostPrice) * quantity : 0;
                const plPercent = avgCostPrice > 0 && cost > 0 ? ((plAmount / cost) * 100) : 0;
                
                // Accumulate totals
                totalCost += cost;
                totalPLAmount += plAmount;
                totalQuantity += quantity;
                
                return `
                    <tr class="border-b hover:bg-slate-50" data-symbol="${stock.symbol}">
                        <td class="py-2 px-3 text-center font-medium">${rowNumber}</td>
                        <td class="py-2 px-3 font-medium">${stock.symbol || ''}</td>
                        <td class="py-2 px-3 text-right table-cell">
                            <div id="quantity-display-${stock.symbol}" onclick="startEdit('${stock.symbol}', 'quantity')" 
                                 class="cursor-pointer hover:bg-blue-50 px-2 py-1 rounded transition-colors min-w-[80px] inline-block text-right" title="Click to edit">
                                ${formatNumber(quantity, 0)}
                            </div>
                            <input id="quantity-input-${stock.symbol}" type="text" 
                                   class="hidden w-full text-right px-2 py-1 border-2 border-blue-500 rounded bg-white shadow-lg min-w-[100px] font-mono text-sm" 
                                   value="${quantity}" 
                                   data-original-value="${quantity}"
                                   data-field="quantity"
                                   data-symbol="${stock.symbol}"
                                   oninput="handleInputFormatting('${stock.symbol}', 'quantity', this.value)"
                                   onblur="finishEdit('${stock.symbol}', 'quantity')" 
                                   onkeydown="handleInputNavigation(event, '${stock.symbol}', 'quantity')"
                                   onfocus="this.select()">
                        </td>
                        <td class="py-2 px-3 text-right table-cell">
                            <div id="avgprice-display-${stock.symbol}" onclick="startEdit('${stock.symbol}', 'avgprice')" 
                                 class="cursor-pointer hover:bg-blue-50 px-2 py-1 rounded transition-colors min-w-[80px] inline-block text-right" title="Click to edit">
                                ${formatNumber(avgCostPrice, 2)}
                            </div>
                            <input id="avgprice-input-${stock.symbol}" type="text" 
                                   class="hidden w-full text-right px-2 py-1 border-2 border-blue-500 rounded bg-white shadow-lg min-w-[100px] font-mono text-sm" 
                                   value="${avgCostPrice}" 
                                   data-original-value="${avgCostPrice}"
                                   data-field="avgprice"
                                   data-symbol="${stock.symbol}"
                                   oninput="handleInputFormatting('${stock.symbol}', 'avgprice', this.value)"
                                   onblur="finishEdit('${stock.symbol}', 'avgprice')" 
                                   onkeydown="handleInputNavigation(event, '${stock.symbol}', 'avgprice')"
                                   onfocus="this.select()">
                        </td>
                        <td class="py-2 px-3 text-right table-cell">${formatNumber(cost, 2)}</td>
                        <td class="py-2 px-3 text-right table-cell ${getValueClass(stock.change)}">${stock.change > 0 ? '+' : ''}${formatNumber(stock.change)}</td>
                        <td class="py-2 px-3 text-right table-cell">${formatNumber(stock.close)}</td>
                        <td class="py-2 px-3 text-right table-cell ${getValueClass(stock.percent_change)}">${stock.percent_change > 0 ? '+' : ''}${formatNumber(stock.percent_change)}%</td>
                        <td class="py-2 px-3 text-right table-cell ${getValueClass(plAmount)}">${plAmount > 0 ? '+' : ''}${formatNumber(plAmount, 2)}</td>
                        <td class="py-2 px-3 text-right table-cell ${getValueClass(plPercent)}">${plPercent > 0 ? '+' : ''}${formatNumber(plPercent, 2)}%</td>
                        <td class="py-2 px-3 text-right table-cell ${getValueClass(stock.nvdr)}">${formatNumber(stock.nvdr, 0)}</td>
                        <td class="py-2 px-3 text-right table-cell ${getValueClass(-stock.shortBaht)}">${formatNumber(stock.shortBaht, 0)}</td>
                        <td class="py-2 px-3 text-center">
                            <div class="w-16 h-8 flex items-center justify-center">
                                <div id="loading-${stock.symbol}" class="text-xs text-slate-400">...</div>
                                <div id="chart-${stock.symbol}" class="chart-mini hidden" data-symbol="${stock.symbol}"></div>
                            </div>
                        </td>
                        <td class="py-2 px-3 text-center">
                            <button onclick="removeFromPortfolio('${stock.symbol}')" 
                                    class="px-2 py-1 rounded text-xs bg-red-100 text-red-700 hover:bg-red-200" 
                                    title="Remove from portfolio">
                                ✕
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Calculate weighted average P/L percentage
            totalPLPercent = totalCost > 0 ? (totalPLAmount / totalCost) * 100 : 0;
            
            // Create the total row
            const totalRow = `
                <tr class="border-t-2 border-blue-300 bg-blue-50 font-semibold" id="portfolio-total-row">
                    <td class="py-3 px-3 text-center font-bold text-blue-800">TOTAL</td>
                    <td class="py-3 px-3 font-bold text-blue-800">${sortedData.length} symbols</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">${formatNumber(totalQuantity, 0)}</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">${formatNumber(totalCost, 2)}</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-right font-bold ${getValueClass(totalPLAmount)}">${totalPLAmount > 0 ? '+' : ''}${formatNumber(totalPLAmount, 2)}</td>
                    <td class="py-3 px-3 text-right font-bold ${getValueClass(totalPLPercent)}">${totalPLPercent > 0 ? '+' : ''}${formatNumber(totalPLPercent, 2)}%</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-right font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-center font-bold text-blue-800">-</td>
                    <td class="py-3 px-3 text-center font-bold text-blue-800">-</td>
                </tr>
            `;
            
            // Combine data rows with total row
            tbody.innerHTML = dataRows + totalRow;
            
            // Create mini charts for all symbols in background (non-blocking)
            sortedData.forEach((stock, index) => {
                // Use requestIdleCallback for better performance and non-blocking behavior
                if (window.requestIdleCallback) {
                    requestIdleCallback(() => {
                        createMiniChart(stock.symbol);
                    }, { timeout: 5000 });
                } else {
                    // Fallback for browsers without requestIdleCallback
                    setTimeout(() => {
                        createMiniChart(stock.symbol);
                    }, index * 100); // Reduced delay for faster loading
                }
            });
            
            // Show edit hints if in edit mode
            if (isEditModeEnabled) {
                showEditHints();
            }
        }

        function renderPortfolioTable(data) {
            const tbody = document.getElementById('portfolio-tbody');
            const loadingState = document.getElementById('loading-state');
            const emptyState = document.getElementById('empty-state');

            loadingState.style.display = 'none';

            if (!data || data.length === 0) {
                emptyState.style.display = 'block';
                tbody.innerHTML = '';
                return;
            }

            emptyState.style.display = 'none';
            tbody.innerHTML = data.map(stock => {
                const isInPortfolio = portfolioSymbols.has(stock.symbol);
                return `
                <tr class="border-b last:border-b-0 hover:bg-slate-50">
                    <td class="content-col py-2 px-3 font-medium whitespace-nowrap">${stock.symbol || ''}</td>
                    <td class="content-col py-2 px-3 text-sm opacity-70 whitespace-nowrap">${stock.sector || ''}</td>
                    <td class="content-col py-2 px-3 text-right table-cell whitespace-nowrap ${getValueClass(stock.change)}">${stock.change > 0 ? '+' : ''}${formatNumber(stock.change)}</td>
                    <td class="content-col py-2 px-3 text-right table-cell whitespace-nowrap">${formatNumber(stock.close)}</td>
                    <td class="content-col py-2 px-3 text-right table-cell whitespace-nowrap ${getValueClass(stock.percent_change)}">${stock.percent_change > 0 ? '+' : ''}${formatNumber(stock.percent_change)}%</td>
                    <td class="content-col py-2 px-3 text-right table-cell whitespace-nowrap ${getValueClass(stock.nvdr)}">${formatNumber(stock.nvdr, 0)}</td>
                    <td class="content-col py-2 px-3 text-right table-cell whitespace-nowrap ${getValueClass(-stock.shortBaht)}">${formatNumber(stock.shortBaht, 0)}</td>
                    <td class="content-col py-2 px-3 text-center whitespace-nowrap">
                        ${isInPortfolio 
                            ? `<button onclick="removeFromPortfolio('${stock.symbol}')" 
                                       class="px-2 py-1 rounded text-xs bg-red-100 text-red-700 hover:bg-red-200" 
                                       title="Remove from portfolio">✓</button>`
                            : `<button onclick="addToPortfolio('${stock.symbol}')" 
                                       class="px-2 py-1 rounded text-xs bg-green-100 text-green-700 hover:bg-green-200" 
                                       title="Add to portfolio">+</button>`
                        }
                    </td>
                </tr>
                `;
            }).join('');
        }

        // Sorting and filtering
        function filterAndSort() {
            let filtered = originalData.filter(stock => 
                !searchQuery || stock.symbol.toLowerCase().includes(searchQuery.toLowerCase())
            );

            filtered.sort((a, b) => {
                const va = a[sortKey];
                const vb = b[sortKey];
                
                if (va == null && vb == null) return 0;
                if (va == null) return sortDir === 'asc' ? -1 : 1;
                if (vb == null) return sortDir === 'asc' ? 1 : -1;
                
                if (va < vb) return sortDir === 'asc' ? -1 : 1;
                if (va > vb) return sortDir === 'asc' ? 1 : -1;
                return 0;
            });

            portfolioData = filtered;
            renderPortfolioTable(portfolioData);

            // Update search result count
            const countEl = document.getElementById('search-count');
            if (countEl) {
                const total = originalData.length || 0;
                countEl.textContent = `${portfolioData.length} / ${total} symbols`;
            }

            // Update All Symbols header meta
            const headerEl = document.getElementById('all-symbols-header');
            if (headerEl) {
                const total = originalData.length || 0;
                if (searchQuery && searchQuery.trim().length > 0) {
                    headerEl.textContent = `Showing ${portfolioData.length} of ${total} symbols for "${searchQuery.toUpperCase()}"`;
                } else {
                    headerEl.textContent = `Showing ${portfolioData.length} of ${total} symbols`;
                }
            }
        }

        function updateSortIndicators() {
            document.querySelectorAll('[id^="sort-"]').forEach(el => {
                el.textContent = '↕';
                el.className = 'text-xs opacity-30';
            });

            const sortEl = document.getElementById(`sort-${sortKey}`);
            if (sortEl) {
                sortEl.textContent = sortDir === 'asc' ? '▲' : '▼';
                sortEl.className = 'text-xs opacity-80';
            }
        }

        function toggleSort(key) {
            if (key === sortKey) {
                sortDir = sortDir === 'asc' ? 'desc' : 'asc';
            } else {
                sortKey = key;
                sortDir = 'asc';
            }
            updateSortIndicators();
            filterAndSort();
        }

        // Export functionality
        async function exportCSV() {
            try {
                const currentDate = document.getElementById('portfolio-date-picker').value;
                const url = `/api/portfolio/export.csv${currentDate ? `?portfolio_date=${currentDate}` : ''}`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404) {
                        alert('No portfolio data found to export.');
                    } else {
                        const error = await response.text();
                        alert(`Export failed: ${error}`);
                    }
                    return;
                }

                // Create download link for the CSV file
                const blob = await response.blob();
                const downloadUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `my-portfolio-${currentDate || new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                URL.revokeObjectURL(downloadUrl);
                
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export portfolio data.');
            }
        }

        // Create mini chart for a symbol using SVG
        async function createMiniChart(symbol, retryCount = 0) {
            try {
                const canvas = document.getElementById(`chart-${symbol}`);
                const loading = document.getElementById(`loading-${symbol}`);
                if (!canvas || !loading) return;

                // Fetch chart data with retry logic
                let response;
                try {
                    const url = `/api/series/symbol/${symbol}`;
                    response = await fetch(url);
                } catch (fetchError) {
                    console.warn(`Network error fetching data for ${symbol}:`, fetchError);
                    if (retryCount < 2) {
                        // Show retry indicator
                        loading.textContent = retryCount === 0 ? '↻' : '↻↻';
                        // Retry after 1 second
                        setTimeout(() => createMiniChart(symbol, retryCount + 1), 1000);
                        return;
                    }
                    loading.textContent = '!';
                    return;
                }

                if (!response.ok) {
                    console.warn(`Failed to fetch chart data for ${symbol}: ${response.status}`);
                    
                    // Special handling for 503 errors (server overload)
                    if (response.status === 503) {
                        if (retryCount < 3) {
                            // Show retry indicator with longer delay for 503 errors
                            loading.textContent = retryCount === 0 ? '↻' : retryCount === 1 ? '↻↻' : '↻↻↻';
                            // Retry after 2-4 seconds for 503 errors to give server time to recover
                            const delay = 2000 + (retryCount * 1000); // 2s, 3s, 4s
                            setTimeout(() => createMiniChart(symbol, retryCount + 1), delay);
                            return;
                        }
                        loading.textContent = '⚠️';
                        return;
                    }
                    
                    // For other errors, use normal retry logic
                    if (retryCount < 2) {
                        // Show retry indicator
                        loading.textContent = retryCount === 0 ? '↻' : '↻↻';
                        // Retry after 1 second
                        setTimeout(() => createMiniChart(symbol, retryCount + 1), 1000);
                        return;
                    }
                    loading.textContent = '!';
                    return;
                }

                const data = await response.json();
                
                if (!data.series || data.series.length === 0) {
                    console.warn(`No chart data for ${symbol}`);
                    loading.textContent = '-';
                    return;
                }

                // Verify the data is for the correct symbol by checking the latest close price
                // against the portfolio data
                const portfolioRow = myPortfolioData.find(stock => stock.symbol === symbol);
                if (portfolioRow && portfolioRow.close > 0) { // Only validate if portfolio has valid data
                    const difference = Math.abs(data.latest.close - portfolioRow.close);
                    const percentDifference = (difference / portfolioRow.close) * 100;
                    
                    // Allow larger differences for low-priced stocks and use percentage-based validation
                    const maxAllowedDifference = Math.max(1, portfolioRow.close * 0.1); // 10% or 1, whichever is larger
                    
                    if (difference > maxAllowedDifference) {
                        console.warn(`⚠️ DATA MISMATCH for ${symbol}: API close=${data.latest.close}, Portfolio close=${portfolioRow.close}, Difference=${difference.toFixed(2)} (${percentDifference.toFixed(1)}%)`);
                        console.warn(`⚠️ This might indicate portfolio data is outdated for ${symbol}`);
                        
                        // For large mismatches, still create the chart but log the warning
                        // This handles cases where portfolio data is outdated but API data is correct
                        console.log(`📊 Creating chart anyway - API data appears to be more recent`);
                        console.log(`💡 Tip: Click "Refresh Portfolio" to update portfolio data with latest prices`);
                        
                        // Auto-update portfolio data with API data for this symbol
                        if (portfolioRow && portfolioRow.close === 0) {
                            console.log(`🔄 Auto-updating portfolio data for ${symbol} with API data`);
                            portfolioRow.close = data.latest.close;
                            portfolioRow.change = data.latest.change;
                            portfolioRow.percent_change = data.latest.change_percent;
                            
                            // Trigger a re-render of the portfolio table to show updated data
                            setTimeout(() => {
                                renderMyPortfolio(myPortfolioData);
                            }, 100);
                        }
                    }
                }


                // Calculate min/max for proper scaling
                const values = data.series.map(item => item.value);
                const minValue = Math.min(...values);
                const maxValue = Math.max(...values);
                const range = maxValue - minValue;
                const padding = range * 0.1; // 10% padding

                // Create SVG chart
                const width = 64;
                const height = 32;
                const margin = 2;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;

                // Create SVG element
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                // Create path for the line
                const points = values.map((value, index) => {
                    const x = margin + (index / (values.length - 1)) * chartWidth;
                    const y = margin + chartHeight - ((value - (minValue - padding)) / ((maxValue + padding) - (minValue - padding))) * chartHeight;
                    return `${x},${y}`;
                });

                const pathData = `M ${points.join(' L ')}`;

                // Create the path element
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', data.latest.change >= 0 ? '#10b981' : '#ef4444');
                path.setAttribute('stroke-width', '1');
                path.setAttribute('fill', 'none');

                svg.appendChild(path);

                // Replace canvas with SVG
                canvas.parentNode.replaceChild(svg, canvas);

                // Hide loading
                loading.classList.add('hidden');


            } catch (error) {
                console.error(`Error creating mini chart for ${symbol}:`, error);
                const loading = document.getElementById(`loading-${symbol}`);
                if (loading) loading.textContent = '!';
            }
        }

        // Save-to-DB with SSE progress
        function startDbProgress() {
            const box = document.getElementById('db-progress');
            const msg = document.getElementById('db-progress-message');
            const det = document.getElementById('db-progress-details');
            box.classList.remove('hidden');
            msg.textContent = 'Starting…'; det.textContent = '';

            const es = new EventSource('/api/progress');
            es.onmessage = (event) => {
                const data = JSON.parse(event.data || '{}');
                msg.textContent = data.message || '';
                const d = data.details || {};
                const pieces = [];
                if (d.records_count) pieces.push(`Records: ${d.records_count}`);
                if (d.current_sector) pieces.push(`Sector: ${d.current_sector}`);
                if (d.trade_date) pieces.push(`Date: ${d.trade_date}`);
                det.textContent = pieces.join('  ');

                // Also update the status bar with the same information
                showDatabaseUpdateStatus(data);

                if (data.status === 'completed' || data.status === 'error') {
                    es.close();
                    if (data.status === 'completed') {
                        // Hide after a short delay and refresh
                        setTimeout(() => { box.classList.add('hidden'); }, 1500);
                        // Soft refresh dashboard after save completes
                        document.getElementById('refresh-btn').click();
                    }
                }
            };
            es.onerror = () => { try { es.close(); } catch(_){} };
            return es;
        }

        async function saveToDatabase(endpoint = '/api/save-to-database') {
            const es = startDbProgress();
            try {
                const res = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' } });
                if (!res.ok) {
                    const err = await res.json().catch(() => ({}));
                    throw new Error(err.detail?.message || err.detail?.error || 'Update failed');
                }
                const result = await res.json();
                
                // Log detailed results for debugging
                console.log('Database save result:', result);
                if (result.failed_components && result.failed_components.length > 0) {
                    console.warn('Failed components:', result.failed_components);
                    console.warn('Summary:', result.summary);
                }
                
                return result;
            } catch (e) {
                console.error('Update error:', e);
                const box = document.getElementById('db-progress');
                const msg = document.getElementById('db-progress-message');
                msg.textContent = `Error: ${e.message || e}`;
                // Keep progress box visible for user context
            } finally {
                // EventSource closed by handler on completion/error
            }
        }

        // Refresh Data from database only
        function startRefreshProgress() {
            const box = document.getElementById('db-progress');
            const msg = document.getElementById('db-progress-message');
            const det = document.getElementById('db-progress-details');
            box.classList.remove('hidden');
            msg.textContent = 'Loading from database…';
            det.textContent = '';

            return {
                finish(success = true) {
                    msg.textContent = success ? '✅ Data refreshed' : '❌ Refresh failed';
                    setTimeout(() => { box.classList.add('hidden'); }, 900);
                }
            };
        }

        // Auto update system with status tracking
        let autoUpdateInterval = null;
        let lastUpdateTime = null;
        let isUpdating = false;
        
        async function startAutoUpdate(needsFullRefresh = false) {
            // First update immediately
            updateTimestamp('Updating...');
            isUpdating = true;
            
            try {
                await autoUpdateDatabase(true, needsFullRefresh);
                // Silently refresh data after background update completes
                console.log('Background update completed, refreshing data...');
                await refreshDataAfterUpdate();
                // Hide loading state
                document.getElementById('loading-state').style.display = 'none';
                
                lastUpdateTime = new Date();
                updateTimestamp(`Updated at ${lastUpdateTime.toLocaleTimeString()}`);
                
            } catch (error) {
                console.warn('Background update failed:', error);
                updateTimestamp('Update failed', '#ef4444');
                
                // Show error state if no data exists
                const hasData = document.querySelector('#portfolio-tbody tr');
                if (!hasData) {
                    document.getElementById('loading-state').innerHTML = `
                        <div class="text-center py-8">
                            <div class="text-red-500 text-4xl mb-4">❌</div>
                            <h3 class="text-lg font-medium text-gray-900 mb-2">Setup failed</h3>
                            <p class="text-gray-600">Failed to download market data</p>
                            <button onclick="location.reload()" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                                Try Again
                            </button>
                        </div>
                    `;
                }
            } finally {
                isUpdating = false;
            }
            
            // Note: Periodic updates removed per user request - only update on PC startup
        }
        
        function updateTimestamp(text, color = '') {
            const timestampEl = document.getElementById('status-timestamp');
            if (timestampEl) {
                timestampEl.textContent = text;
                timestampEl.style.color = color;
            }
        }

        // Function to refresh data from database only (no updates)
        async function refreshFromDatabase() {
            try {
                // Load existing data from database only - show ALL symbols for the main table
                const [dashboardData, portfolioData, setIndexData, setIndexChartData, timestampsData] = await Promise.all([
                    fetchDashboardData(null, true), // Show all symbols
                    fetchMyPortfolio(),
                    fetchSetIndexData(),
                    fetch('/api/series/set-index').then(res => res.json()).catch(() => null),
                    fetchDataTimestamps()
                ]);
                
                // Calculate summary from dashboard data
                const summaryData = await fetchSummaryData(dashboardData);
                
                // Display the data
                if (dashboardData && dashboardData.portfolio_stocks && dashboardData.portfolio_stocks.length > 0) {
                    originalData = dashboardData.portfolio_stocks || [];
                    renderDashboard(dashboardData, summaryData, portfolioData);
                }
                
                if (setIndexData && setIndexData.success && setIndexData.data && setIndexData.data.length > 0) {
                    renderSetIndex(setIndexData);
                }
                
                if (setIndexChartData && setIndexChartData.series && setIndexChartData.series.length > 0) {
                    renderSetIndexChart(setIndexChartData);
                }
                
                if (timestampsData && timestampsData.success) {
                    renderDataTimestamps(timestampsData);
                }
                
                // Hide loading state
                document.getElementById('loading-state').style.display = 'none';
                
            } catch (error) {
                console.error('Error refreshing data from database:', error);
                throw error;
            }
        }

        // Function to render SET index chart
        async function renderSetIndexChart(data) {
            if (!data || !data.series) return;
            
            const latest = data.latest || {};
            const chgClass = latest.change > 0 ? 'text-green-600' : (latest.change < 0 ? 'text-red-600' : '');
            const meta = document.getElementById('set-latest-meta');
            if (meta && latest && latest.close != null) {
                meta.textContent = `${latest.date} • Close ${latest.close} (${latest.change > 0 ? '+' : ''}${latest.change} / ${latest.change_percent}%)`;
                meta.className = `text-xs ${chgClass.replace('600','700')} opacity-80`;
            }

            // Wait for Chart.js to load
            let retries = 0;
            const maxRetries = 20;
            
            const waitForLibrary = () => {
                return new Promise((resolve, reject) => {
                    const checkLibrary = () => {
                        if (window.Chart) {
                            resolve();
                        } else if (retries < maxRetries) {
                            retries++;
                            setTimeout(checkLibrary, 100);
                        } else {
                            reject(new Error('Chart.js library failed to load after ' + maxRetries + ' attempts'));
                        }
                    };
                    checkLibrary();
                });
            };

            try {
                await waitForLibrary();

                // Render chart with Chart.js
                const container = document.getElementById('setChart');
                
                if (container) {
                    // Clear container and create canvas
                    container.innerHTML = '<canvas id="setChartCanvas"></canvas>';
                    const canvas = document.getElementById('setChartCanvas');
                    canvas.width = container.clientWidth || 800;
                    canvas.height = container.clientHeight || 400;
                    
                    // Add range selector buttons above the chart
                    const rangeContainer = document.createElement('div');
                    rangeContainer.className = 'flex gap-1 mb-2 justify-center';
                    rangeContainer.innerHTML = `
                        <button class="range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded" data-range="90">3M</button>
                        <button class="range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded" data-range="365">1Y</button>
                        <button class="range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded" data-range="1825">5Y</button>
                        <button class="range-btn px-3 py-1 text-sm bg-blue-500 text-white rounded" data-range="all">All</button>
                    `;
                    container.insertBefore(rangeContainer, canvas);
                    
                    // Prepare data for Chart.js
                    const chartData = {
                        labels: data.series.map(item => item.time),
                        datasets: [{
                            label: 'SET Index',
                            data: data.series.map(item => item.value),
                            borderColor: '#1e40af',
                            backgroundColor: 'rgba(30,64,175,0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 0
                        }]
                    };
                    
                    const chartConfig = {
                        type: 'line',
                        data: chartData,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        parser: 'yyyy-MM-dd',
                                        displayFormats: {
                                            day: 'MMM dd',
                                            month: 'MMM yyyy'
                                        }
                                    },
                                    display: true,
                                    grid: {
                                        color: '#eee'
                                    }
                                },
                                y: {
                                    display: true,
                                    grid: {
                                        color: '#eee'
                                    }
                                }
                            }
                        }
                    };
                    
                    const chart = new window.Chart(canvas, chartConfig);
                    
                    // Add range selector functionality
                    const allData = [...data.series];
                    let currentRange = 'all';

                    function filterDataByRange(days) {
                        if (days === 'all') {
                            return allData; // Show all historical data
                        }
                        
                        // Get the latest date from the data
                        const latestDate = new Date(Math.max(...allData.map(item => new Date(item.time))));
                        const cutoffDate = new Date(latestDate);
                        cutoffDate.setDate(cutoffDate.getDate() - days);
                        
                        return allData.filter(item => new Date(item.time) >= cutoffDate);
                    }

                    function updateChart(range) {
                        const filteredData = filterDataByRange(range);
                        chart.data.labels = filteredData.map(item => item.time);
                        chart.data.datasets[0].data = filteredData.map(item => item.value);
                        chart.update('none');
                        
                        // Update active button styling
                        rangeContainer.querySelectorAll('.range-btn').forEach(btn => {
                            if (btn.dataset.range == range) {
                                btn.className = 'range-btn px-3 py-1 text-sm bg-blue-500 text-white rounded';
                            } else {
                                btn.className = 'range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded';
                            }
                        });
                    }

                    // Add click handlers for range buttons
                    rangeContainer.addEventListener('click', (e) => {
                        if (e.target.classList.contains('range-btn')) {
                            const range = e.target.dataset.range;
                            currentRange = range;
                            updateChart(range);
                        }
                    });

                    // Initialize with default range
                    updateChart(currentRange);
                }
            } catch (chartError) {
                console.error('Chart rendering failed:', chartError);
            }
        }

        // Initialize the dashboard (database-only for fast loading)
        async function initDashboard() {
            try {
                console.log('🚀 Loading portfolio from database...');
                
                // Load existing data immediately from database
                const [dashboardData, setIndexData, setIndexChartData, timestampsData] = await Promise.all([
                    fetchDashboardData(null, true), // Show all symbols
                    fetchSetIndexData(),
                    fetch('/api/series/set-index').then(res => res.json()).catch(() => null),
                    fetchDataTimestamps()
                ]);
                
                // Calculate summary from dashboard data
                const summaryData = await fetchSummaryData(dashboardData);
                
                // Display the existing data first
                let hasData = false;
                if (dashboardData && dashboardData.portfolio_stocks && dashboardData.portfolio_stocks.length > 0) {
                    originalData = dashboardData.portfolio_stocks || [];
                    renderDashboard(dashboardData, summaryData, null); // Don't pass portfolioData, we'll load it separately
                    hasData = true;
                }
                
                if (setIndexData && setIndexData.success && setIndexData.data && setIndexData.data.length > 0) {
                    renderSetIndex(setIndexData);
                    hasData = true;
                }
                
                // Render SET index chart immediately if data is available
                if (setIndexChartData && setIndexChartData.series && setIndexChartData.series.length > 0) {
                    renderSetIndexChart(setIndexChartData);
                }
                
                // Render timestamps data
                if (timestampsData && timestampsData.success) {
                    renderDataTimestamps(timestampsData);
                }
                
                // Portfolio data will be loaded after available dates are fetched
                
                // Always hide loading state since server pre-loads data on startup
                document.getElementById('loading-state').style.display = 'none';
                
                if (hasData) {
                    console.log('✅ Portfolio loaded from database');
                    showStatus('✅', 'Portfolio ready', 'Updated on server startup + auto-scheduled at 10:30, 13:00, 17:30 (weekdays)', 'success');
                    // Auto-hide success status after 3 seconds
                    setTimeout(() => {
                        const statusEl = document.getElementById('status-message');
                        if (statusEl && statusEl.textContent.includes('Portfolio ready')) {
                            statusEl.style.display = 'none';
                        }
                    }, 3000);
                } else {
                    console.log('⚠️ No data found in database');
                    showStatus('⚠️', 'No data available', 'Server is still loading fresh data. Please refresh page in a moment.', 'warning');
                }
                
                // Skip auto-update since server already scrapes on startup
                // Users can manually refresh if needed
                console.log('🔄 Skipping auto-update (server pre-loads data on startup)');
                
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                showStatus('❌', 'Failed to load dashboard', error.message, 'error');
            }
        }
        
        // Function to refresh data after background update
        async function refreshDataAfterUpdate() {
            try {
                const [dashboardData, portfolioData, setIndexData, setIndexChartData, timestampsData] = await Promise.all([
                    fetchDashboardData(null, true), // Show all symbols
                    fetchMyPortfolio(),
                    fetchSetIndexData(),
                    fetch('/api/series/set-index').then(res => res.json()).catch(() => null),
                    fetchDataTimestamps()
                ]);
                
                // Calculate summary from dashboard data
                const summaryData = await fetchSummaryData(dashboardData);
                
                if (dashboardData) {
                    originalData = dashboardData.portfolio_stocks || [];
                    renderDashboard(dashboardData, summaryData, portfolioData);
                }
                
                if (setIndexData) {
                    renderSetIndex(setIndexData);
                }
                
                if (setIndexChartData && setIndexChartData.series && setIndexChartData.series.length > 0) {
                    renderSetIndexChart(setIndexChartData);
                }
                
                if (timestampsData && timestampsData.success) {
                    renderDataTimestamps(timestampsData);
                }
                
            } catch (error) {
                console.error('Error refreshing data after update:', error);
            }
        }
        
        // Shared function to render dashboard data
        function renderDashboard(dashboardData, summaryData, portfolioData) {
            // Update trade date with data source information
            const tradeDateEl = document.getElementById('trade-date');
            const lastUpdatedEl = document.getElementById('last-updated');
            if (dashboardData.trade_date) {
                let tradeDateText = `Trade Date: ${dashboardData.trade_date}`;
                
                // Add info about different data dates if available
                if (dashboardData.data_dates) {
                    const dateDates = dashboardData.data_dates;
                    const mainDate = dashboardData.trade_date;
                    const differentDates = [];
                    
                    if (dateDates.nvdr && dateDates.nvdr !== mainDate) {
                        differentDates.push(`NVDR: ${dateDates.nvdr}`);
                    }
                    if (dateDates.short_sales) {
                        if (Array.isArray(dateDates.short_sales)) {
                            // Multiple dates - show as range or "mixed"
                            if (dateDates.short_sales.length === 2 && dateDates.short_sales.includes(mainDate)) {
                                const otherDate = dateDates.short_sales.find(d => d !== mainDate);
                                differentDates.push(`Short Sales: ${otherDate}-${mainDate} (mixed)`);
                            } else {
                                differentDates.push(`Short Sales: ${dateDates.short_sales.join('-')} (mixed)`);
                            }
                        } else if (dateDates.short_sales !== mainDate) {
                            differentDates.push(`Short Sales: ${dateDates.short_sales}`);
                        }
                    }
                    
                    if (differentDates.length > 0) {
                        tradeDateText += ` (${differentDates.join(', ')})`;
                    }
                }
                
                tradeDateEl.textContent = tradeDateText;
                lastUpdatedEl.textContent = new Date().toLocaleString();
            }

            // Render all sections
            renderSummaryCards(summaryData);
            renderInvestorSummary(dashboardData.investor_summary, dashboardData.data_dates);
            
            // Portfolio will be loaded separately by date
            
            // Sort and render portfolio table (default: symbol A-Z)
            filterAndSort();
            updateSortIndicators();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (progressEventSource) {
                progressEventSource.close();
            }
        });

        // Edit mode functions
        function toggleEditMode() {
            // If we're currently in edit mode and have unsaved changes, warn the user
            if (isEditModeEnabled && pendingChanges && pendingChanges.size > 0) {
                const changeText = pendingChanges.size === 1 ? '1 unsaved change' : `${pendingChanges.size} unsaved changes`;
                const confirmExit = confirm(`⚠️ WARNING: You have ${changeText}!\n\nAre you sure you want to exit Edit Mode?\n\nYour changes will be lost if you don't save them first.\n\nClick "OK" to exit without saving, or "Cancel" to stay in Edit Mode.`);
                if (!confirmExit) {
                    return;
                }
            }
            
            isEditModeEnabled = !isEditModeEnabled;
            const toggleBtn = document.getElementById('edit-mode-toggle');
            const toggleText = document.getElementById('edit-mode-text');
            const saveBtn = document.getElementById('save-portfolio-btn');
            
            if (isEditModeEnabled) {
                toggleBtn.className = 'px-3 py-1 rounded-lg shadow text-sm bg-red-100 text-red-700 border border-red-300';
                toggleText.textContent = '❌ Cancel';
                saveBtn.classList.remove('hidden');
                
                // Show edit hints
                showEditHints();
            } else {
                toggleBtn.className = 'px-3 py-1 rounded-lg shadow text-sm border';
                toggleText.textContent = '✏️ Edit Mode';
                saveBtn.classList.add('hidden');
                
                // Hide edit hints and cancel any active edits
                hideEditHints();
                
                // Cancel any active edits
                Object.keys(editMode).forEach(key => {
                    const [symbol, field] = key.split('-');
                    cancelEdit(symbol, field);
                });
                
                // Clear pending changes when exiting edit mode
                pendingChanges.clear();
                updateSaveButtonState();
            }
        }
        
        function showEditHints() {
            const editables = document.querySelectorAll('.cursor-pointer[title="Click to edit"]');
            editables.forEach(el => {
                el.classList.add('bg-yellow-50', 'border', 'border-yellow-200');
            });
        }
        
        function hideEditHints() {
            const editables = document.querySelectorAll('.cursor-pointer[title="Click to edit"]');
            editables.forEach(el => {
                el.classList.remove('bg-yellow-50', 'border', 'border-yellow-200');
            });
        }
        
        function startEdit(symbol, field) {
            // Only allow editing if edit mode is enabled
            if (!isEditModeEnabled) {
                alert('Please enable Edit Mode first by clicking the Edit Mode button.');
                return;
            }
            
            const displayEl = document.getElementById(`${field}-display-${symbol}`);
            const inputEl = document.getElementById(`${field}-input-${symbol}`);
            
            if (displayEl && inputEl) {
                // Store the current value as original value for cancellation
                const currentValue = inputEl.value;
                inputEl.setAttribute('data-original-value', currentValue);
                
                // Show input, hide display
                displayEl.classList.add('hidden');
                inputEl.classList.remove('hidden');
                inputEl.focus();
                inputEl.select();
                editMode[`${symbol}-${field}`] = true;
                
                // Pause background updates while editing
                if (typeof pauseAutoUpdate !== 'undefined') {
                    pauseAutoUpdate = true;
                }
                
                console.log(`✏️ Started editing ${symbol} ${field}, original value: ${currentValue}`);
            }
        }
        
        function cancelEdit(symbol, field) {
            const displayEl = document.getElementById(`${field}-display-${symbol}`);
            const inputEl = document.getElementById(`${field}-input-${symbol}`);
            
            if (displayEl && inputEl) {
                // Restore original value
                const originalValue = inputEl.getAttribute('data-original-value') || '0';
                const numericValue = parseFloat(originalValue);
                
                // Update the display with original formatted value
                displayEl.textContent = formatNumber(numericValue, field === 'quantity' ? 0 : 2);
                
                // Restore the input value
                inputEl.value = originalValue;
                
                // Hide input, show display
                displayEl.classList.remove('hidden');
                inputEl.classList.add('hidden');
                delete editMode[`${symbol}-${field}`];
                
                console.log(`❌ Edit cancelled for ${symbol} ${field}, restored to ${originalValue}`);
            }
        }
        
        function finishEdit(symbol, field) {
            const displayEl = document.getElementById(`${field}-display-${symbol}`);
            const inputEl = document.getElementById(`${field}-input-${symbol}`);
            
            if (displayEl && inputEl) {
                const inputValue = inputEl.value.trim();
                // Remove commas and parse the numeric value
                const newValue = inputValue === '' ? 0 : parseFloat(inputValue.replace(/,/g, ''));
                
                // Validate input
                if (isNaN(newValue) || newValue < 0) {
                    alert('Please enter a valid positive number');
                    inputEl.focus();
                    return;
                }
                
                // Prepare data to save
                const currentRow = myPortfolioData.find(stock => stock.symbol === symbol);
                if (!currentRow) {
                    // If no current row, create default values
                    currentRow = { symbol: symbol, quantity: 0, avg_cost_price: 0 };
                }
                
                let quantity = currentRow.quantity || 0;
                let avgCostPrice = currentRow.avg_cost_price || 0;
                
                if (field === 'quantity') {
                    quantity = newValue;
                } else if (field === 'avgprice') {
                    avgCostPrice = newValue;
                }
                
                // Update the current row data
                currentRow.quantity = quantity;
                currentRow.avg_cost_price = avgCostPrice;
                
                // Calculate real-time values
                const cost = quantity * avgCostPrice;
                const closePrice = currentRow.close || 0;
                const plAmount = quantity > 0 && avgCostPrice > 0 ? (closePrice - avgCostPrice) * quantity : 0;
                const plPercent = avgCostPrice > 0 && cost > 0 ? ((plAmount / cost) * 100) : 0;
                
                // Update display immediately with formatted value
                displayEl.textContent = formatNumber(newValue, field === 'quantity' ? 0 : 2);
                
                // Update all related values in real-time
                updateCalculatedValues(symbol, cost, plAmount, plPercent);
                
                // Track changes for manual save instead of auto-saving
                if ((quantity > 0 && avgCostPrice > 0) || (quantity === 0 && avgCostPrice === 0)) {
                    // Mark this symbol as having pending changes
                    if (!pendingChanges) pendingChanges = new Set();
                    pendingChanges.add(symbol);
                    updateSaveButtonState();
                    console.log(`📝 Changes tracked for ${symbol}: qty=${quantity}, price=${avgCostPrice} - ready to save`);
                } else {
                    console.log(`⏳ Partial data for ${symbol}: qty=${quantity}, price=${avgCostPrice} - not ready to save yet`);
                }
                
                // Hide input, show display
                displayEl.classList.remove('hidden');
                inputEl.classList.add('hidden');
                delete editMode[`${symbol}-${field}`];
            }
        }
        
        // Debounce timer for live calculations
        let liveCalcTimer = null;
        
        function updateLiveCalculations(symbol, field, numericValue = null) {
            // Clear previous timer
            if (liveCalcTimer) {
                clearTimeout(liveCalcTimer);
            }
            
            // Debounce: wait 150ms before calculating
            liveCalcTimer = setTimeout(() => {
                try {
                    let newValue = numericValue;
                    
                    // If no numeric value provided, get it from input
                    if (newValue === null) {
                        const inputEl = document.getElementById(`${field}-input-${symbol}`);
                        if (!inputEl) return;
                        
                        const inputValue = inputEl.value.trim();
                        newValue = inputValue === '' ? 0 : parseFloat(inputValue.replace(/,/g, ''));
                    }
                    
                    // Skip if invalid number
                    if (isNaN(newValue) || newValue < 0) return;
                    
                    // Get current row data
                    const currentRow = myPortfolioData.find(stock => stock.symbol === symbol);
                    if (!currentRow) return;
                    
                    // Get current values
                    let quantity = currentRow.quantity || 0;
                    let avgCostPrice = currentRow.avg_cost_price || 0;
                    
                    // Update with new input value
                    if (field === 'quantity') {
                        quantity = newValue;
                    } else if (field === 'avgprice') {
                        avgCostPrice = newValue;
                    }
                    
                    // Update the current row data
                    currentRow.quantity = quantity;
                    currentRow.avg_cost_price = avgCostPrice;
                    
                    // Calculate live values
                    const cost = quantity * avgCostPrice;
                    const closePrice = currentRow.close || 0;
                    const plAmount = quantity > 0 && avgCostPrice > 0 ? (closePrice - avgCostPrice) * quantity : 0;
                    const plPercent = avgCostPrice > 0 && cost > 0 ? ((plAmount / cost) * 100) : 0;
                    
                    // Update display using requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        updateCalculatedValues(symbol, cost, plAmount, plPercent);
                    });
                    
                } catch (error) {
                    console.error(`❌ Error in updateLiveCalculations:`, error);
                }
            }, 150);
        }
        
        function updateCalculatedValues(symbol, cost, plAmount, plPercent) {
            // Find the row for this symbol
            const row = document.querySelector(`tr[data-symbol="${symbol}"]`);
            if (!row) return;
            
            // Get all cells in the row
            const cells = row.querySelectorAll('td');
            
            // Update based on column positions (after removing sector column):
            // 0: No., 1: Symbol, 2: Quantity, 3: Avg Cost Price, 4: Cost, 5: Change, 6: Close Price, 7: %Change, 8: P/L, 9: %P/L, 10: NVDR, 11: Short Sales, 12: Chart, 13: Action
            
            if (cells[4]) { // Cost column
                cells[4].textContent = formatNumber(cost, 2);
            }
            
            if (cells[8]) { // P/L Amount column
                cells[8].textContent = (plAmount > 0 ? '+' : '') + formatNumber(plAmount, 2);
                cells[8].className = `py-2 px-3 text-right table-cell ${getValueClass(plAmount)}`;
            }
            
            if (cells[9]) { // P/L Percent column
                cells[9].textContent = (plPercent > 0 ? '+' : '') + formatNumber(plPercent, 2) + '%';
                cells[9].className = `py-2 px-3 text-right table-cell ${getValueClass(plPercent)}`;
            }
            
            // Update the total row
            updateTotalRow();
        }
        
        function updateTotalRow() {
            // Recalculate totals from all portfolio data
            let totalCost = 0;
            let totalPLAmount = 0;
            let totalQuantity = 0;
            
            // Get all portfolio rows (excluding the total row)
            const portfolioRows = document.querySelectorAll('tr[data-symbol]');
            
            portfolioRows.forEach(row => {
                const symbol = row.getAttribute('data-symbol');
                const currentRow = myPortfolioData.find(stock => stock.symbol === symbol);
                
                if (currentRow) {
                    const quantity = currentRow.quantity || 0;
                    const avgCostPrice = currentRow.avg_cost_price || 0;
                    const cost = quantity * avgCostPrice;
                    const closePrice = currentRow.close || 0;
                    const plAmount = quantity > 0 && avgCostPrice > 0 ? (closePrice - avgCostPrice) * quantity : 0;
                    
                    totalCost += cost;
                    totalPLAmount += plAmount;
                    totalQuantity += quantity;
                }
            });
            
            // Calculate weighted average P/L percentage
            const totalPLPercent = totalCost > 0 ? (totalPLAmount / totalCost) * 100 : 0;
            
            // Update the total row
            const totalRow = document.getElementById('portfolio-total-row');
            if (totalRow) {
                const cells = totalRow.querySelectorAll('td');
                
                if (cells[2]) { // Total Quantity
                    cells[2].textContent = formatNumber(totalQuantity, 0);
                }
                
                if (cells[4]) { // Total Cost
                    cells[4].textContent = formatNumber(totalCost, 2);
                }
                
                if (cells[8]) { // Total P/L Amount
                    cells[8].textContent = (totalPLAmount > 0 ? '+' : '') + formatNumber(totalPLAmount, 2);
                    cells[8].className = `py-3 px-3 text-right font-bold ${getValueClass(totalPLAmount)}`;
                }
                
                if (cells[9]) { // Total P/L Percent
                    cells[9].textContent = (totalPLPercent > 0 ? '+' : '') + formatNumber(totalPLPercent, 2) + '%';
                    cells[9].className = `py-3 px-3 text-right font-bold ${getValueClass(totalPLPercent)}`;
                }
            }
        }
        
        // Track ongoing saves to prevent duplicates
        const ongoingSaves = new Set();
        
        // Track pending changes for manual save
        let pendingChanges = new Set();
        
        // Enhanced input formatting and navigation functions
        function handleInputFormatting(symbol, field, value) {
            // Remove all non-numeric characters except decimal point
            let cleanValue = value.replace(/[^\d.]/g, '');
            
            // Ensure only one decimal point
            const parts = cleanValue.split('.');
            if (parts.length > 2) {
                cleanValue = parts[0] + '.' + parts.slice(1).join('');
            }
            
            // Format with commas for thousands
            if (field === 'quantity') {
                // For quantity, remove decimal and format with commas
                cleanValue = cleanValue.split('.')[0];
                if (cleanValue) {
                    const numValue = parseInt(cleanValue);
                    if (!isNaN(numValue)) {
                        cleanValue = numValue.toLocaleString();
                    }
                }
            } else if (field === 'avgprice') {
                // For price, allow up to 2 decimal places
                if (parts.length === 2 && parts[1].length > 2) {
                    cleanValue = parts[0] + '.' + parts[1].substring(0, 2);
                }
                if (cleanValue && !cleanValue.includes('.')) {
                    const numValue = parseFloat(cleanValue);
                    if (!isNaN(numValue)) {
                        cleanValue = numValue.toLocaleString();
                    }
                }
            }
            
            // Update input value
            const inputEl = document.getElementById(`${field}-input-${symbol}`);
            if (inputEl) {
                inputEl.value = cleanValue;
            }
            
            // Update live calculations with the numeric value
            const numericValue = parseFloat(cleanValue.replace(/,/g, '')) || 0;
            updateLiveCalculations(symbol, field, numericValue);
        }
        
        function handleInputNavigation(event, symbol, field) {
            const key = event.key;
            
            if (key === 'Tab') {
                event.preventDefault();
                // Move to next field (right)
                const nextField = field === 'quantity' ? 'avgprice' : 'quantity';
                const nextInput = document.getElementById(`${nextField}-input-${symbol}`);
                if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                }
            } else if (key === 'Enter') {
                event.preventDefault();
                // Move to next row (down)
                const currentRow = document.querySelector(`tr[data-symbol="${symbol}"]`);
                if (currentRow) {
                    const nextRow = currentRow.nextElementSibling;
                    if (nextRow) {
                        const nextSymbol = nextRow.getAttribute('data-symbol');
                        if (nextSymbol) {
                            const nextInput = document.getElementById(`${field}-input-${nextSymbol}`);
                            if (nextInput) {
                                nextInput.focus();
                                nextInput.select();
                            }
                        }
                    }
                }
                // If no next row, finish editing
                finishEdit(symbol, field);
            } else if (key === 'Escape') {
                event.preventDefault();
                cancelEdit(symbol, field);
            }
        }
        
        // Add a simple test function to verify save functionality
        function testSaveFunction() {
            console.log('🧪 Testing save function...');
            if (pendingChanges && pendingChanges.size > 0) {
                console.log(`📝 Found ${pendingChanges.size} pending changes:`, Array.from(pendingChanges));
                saveAllChanges();
            } else {
                console.log('📝 No pending changes to save');
            }
        }
        
        // Test server connectivity
        async function testServerConnection() {
            try {
                console.log('🔍 Testing server connection...');
                const response = await fetch('/api/portfolio/available-dates');
                if (response.ok) {
                    console.log('✅ Server is reachable');
                    return true;
                } else {
                    console.log('❌ Server responded with error:', response.status);
                    return false;
                }
            } catch (error) {
                console.error('❌ Server connection failed:', error);
                return false;
            }
        }
        
        async function savePortfolioHolding(symbol, quantity, avgCostPrice) {
            // Prevent duplicate saves for the same symbol
            const saveKey = `${symbol}`;
            if (ongoingSaves.has(saveKey)) {
                console.log(`⏳ Save already in progress for ${symbol}, skipping...`);
                return;
            }
            
            ongoingSaves.add(saveKey);
            
            try {
                const response = await fetch('/api/portfolio/save-holding', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        quantity: quantity,
                        avg_cost_price: avgCostPrice,
                        trade_date: currentPortfolioDate
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`✅ Successfully saved ${symbol}: qty=${quantity}, price=${avgCostPrice}`);
                    // No need to refresh - the live calculations already updated the display
                    // Just clean up the save tracking
                    ongoingSaves.delete(saveKey);
                    return { success: true, result };
                } else {
                    const error = await response.json();
                    console.error('❌ Error saving holding:', error);
                    
                    // Check if it's a table not found error
                    if (error.detail && error.detail.includes('portfolio_holdings')) {
                        const errorMsg = '❌ Portfolio holdings table not found!\n\nPlease create the database table first:\n1. Go to your Supabase SQL Editor\n2. Run the SQL from create_portfolio_holdings_table.sql\n3. Then try editing again.';
                        alert(errorMsg);
                        throw new Error(errorMsg);
                    } else {
                        const errorMsg = `Error saving holding: ${error.detail}`;
                        alert(errorMsg);
                        throw new Error(errorMsg);
                    }
                }
            } catch (error) {
                console.error('❌ Error saving holding:', error);
                console.error('❌ Error details:', {
                    symbol,
                    quantity,
                    avgCostPrice,
                    trade_date: currentPortfolioDate,
                    error_message: error.message,
                    error_stack: error.stack
                });
                
                // Better error handling for network issues
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    console.error('🌐 Network error detected - server may be down or unreachable');
                    alert(`❌ Network error: Cannot connect to server for ${symbol}. Please check if the server is running.`);
                } else {
                    alert(`Error saving holding for ${symbol}: ${error.message}`);
                }
                
                throw error; // Re-throw the error so saveAllChanges can catch it
            } finally {
                // Always remove from ongoing saves
                ongoingSaves.delete(saveKey);
            }
        }
        
        function updateSaveButtonState() {
            const saveBtn = document.getElementById('save-portfolio-btn');
            const saveText = document.getElementById('save-portfolio-text');
            
            if (pendingChanges && pendingChanges.size > 0) {
                saveText.textContent = `💾 Save Changes (${pendingChanges.size})`;
                saveBtn.classList.add('bg-orange-100', 'text-orange-700', 'border-orange-300');
                saveBtn.classList.remove('bg-green-100', 'text-green-700');
            } else {
                saveText.textContent = '💾 Save Changes';
                saveBtn.classList.remove('bg-orange-100', 'text-orange-700', 'border-orange-300');
                saveBtn.classList.add('bg-green-100', 'text-green-700');
            }
        }
        
        async function saveAllChanges() {
            if (!pendingChanges || pendingChanges.size === 0) {
                alert('No changes to save!');
                return;
            }
            
            const saveBtn = document.getElementById('save-portfolio-btn');
            const saveText = document.getElementById('save-portfolio-text');
            const originalText = saveText.textContent;
            
            // Show saving state
            saveBtn.disabled = true;
            saveText.textContent = '💾 Saving...';
            
            // Test server connectivity first
            const serverReachable = await testServerConnection();
            if (!serverReachable) {
                saveText.textContent = '❌ Server Error!';
                setTimeout(() => {
                    updateSaveButtonState();
                    saveBtn.disabled = false;
                }, 2000);
                alert('❌ Cannot connect to server. Please check if the server is running.');
                return;
            }
            
            // Clear pending changes immediately to prevent race conditions
            const changesToSave = Array.from(pendingChanges);
            pendingChanges.clear();
            updateSaveButtonState();
            
            console.log(`🚀 Starting to save ${changesToSave.length} changes immediately...`);
            
            try {
                let successCount = 0;
                let errorCount = 0;
                
                // Save all pending changes with high priority
                const savePromises = changesToSave.map(async (symbol) => {
                    const currentRow = myPortfolioData.find(stock => stock.symbol === symbol);
                    if (currentRow) {
                        const quantity = currentRow.quantity || 0;
                        const avgCostPrice = currentRow.avg_cost_price || 0;
                        
                        console.log(`💾 Saving ${symbol}: qty=${quantity}, price=${avgCostPrice}`);
                        
                        try {
                            const result = await savePortfolioHolding(symbol, quantity, avgCostPrice);
                            if (result && result.success) {
                                successCount++;
                                console.log(`✅ Successfully saved ${symbol}`);
                                return { success: true, symbol };
                            } else {
                                errorCount++;
                                console.error(`❌ Failed to save ${symbol}: No success response`);
                                return { success: false, symbol, error: 'No success response' };
                            }
                        } catch (error) {
                            console.error(`❌ Failed to save ${symbol}:`, error);
                            errorCount++;
                            return { success: false, symbol, error: error.message };
                        }
                    } else {
                        console.error(`❌ Could not find data for ${symbol}`);
                        errorCount++;
                        return { success: false, symbol, error: 'Data not found' };
                    }
                });
                
                // Wait for all saves to complete
                const results = await Promise.allSettled(savePromises);
                
                // Count actual successes and failures
                const actualSuccesses = results.filter(r => r.status === 'fulfilled' && r.value.success).length;
                const actualFailures = results.length - actualSuccesses;
                
                // Show result
                if (actualFailures === 0) {
                    saveText.textContent = '✅ Saved!';
                    console.log(`🎉 Successfully saved all ${actualSuccesses} holdings!`);
                    setTimeout(() => {
                        updateSaveButtonState();
                        saveBtn.disabled = false;
                    }, 2000);
                } else {
                    saveText.textContent = `⚠️ ${actualSuccesses} saved, ${actualFailures} failed`;
                    console.log(`⚠️ Save completed: ${actualSuccesses} successful, ${actualFailures} failed`);
                    setTimeout(() => {
                        updateSaveButtonState();
                        saveBtn.disabled = false;
                    }, 3000);
                }
                
            } catch (error) {
                console.error('❌ Error saving all changes:', error);
                saveText.textContent = '❌ Error!';
                setTimeout(() => {
                    saveText.textContent = originalText;
                    saveBtn.disabled = false;
                }, 2000);
                alert('Error saving changes. Please try again.');
            }
        }
        
        // Global variable for available dates
        let availableDatesSet = new Set();
        let latestAvailableDate = null;
        
        async function loadAvailableDates() {
            try {
                const response = await fetch('/api/portfolio/date-availability');
                const data = await response.json();
                
                if (data.success) {
                    // Store available dates for validation
                    availableDatesSet = new Set(data.available_dates);
                    latestAvailableDate = data.latest_date;
                    
                    const datePickerEl = document.getElementById('portfolio-date-picker');
                    
                    // Set initial value to today
                    const today = new Date().toISOString().split('T')[0];
                    currentPortfolioDate = today;
                    datePickerEl.value = today;
                    
                    // Update UI to show today's status
                    updateDateStatus(today);
                    
                    // First refresh All Symbols table for today's date (provides market data)
                    await refreshAllSymbolsForDate(today);
                    // Then load portfolio by joining holdings with the already loaded market data
                    await loadPortfolioForDate(today);
                    
                    // Set min and max dates (last 90 days)
                    const todayDate = new Date();
                    const minDate = new Date(todayDate.getTime() - (90 * 24 * 60 * 60 * 1000));
                    
                    datePickerEl.min = minDate.toISOString().split('T')[0];
                    datePickerEl.max = todayDate.toISOString().split('T')[0];
                }
            } catch (error) {
                console.error('Error loading date availability:', error);
            }
        }
        
        function updateDateStatus(date) {
            const datePickerEl = document.getElementById('portfolio-date-picker');
            const statusEl = document.getElementById('date-status');
            const isAvailable = availableDatesSet.has(date);
            const today = new Date().toISOString().split('T')[0];
            const isToday = date === today;
            
            // Update input styling
            datePickerEl.classList.remove('date-available', 'date-unavailable');
            if (isAvailable) {
                datePickerEl.classList.add('date-available');
            } else {
                datePickerEl.classList.add('date-unavailable');
            }
            
            // Update status text
            statusEl.classList.remove('available', 'unavailable', 'today');
            if (isToday) {
                statusEl.classList.add('today');
                statusEl.textContent = '📅 Today';
            } else if (isAvailable) {
                statusEl.classList.add('available');
                statusEl.textContent = '✓ Available';
            } else {
                statusEl.classList.add('unavailable');
                statusEl.textContent = '⚠️ No data';
            }
        }
        
        async function refreshAllSymbolsForDate(selectedDate) {
            try {
                console.log(`📅 Refreshing All Symbols table for date: ${selectedDate}`);
                
                // Show loading state for All Symbols table
                const loadingState = document.getElementById('loading-state');
                const emptyState = document.getElementById('empty-state');
                const tbody = document.getElementById('portfolio-tbody');
                
                loadingState.style.display = 'block';
                emptyState.style.display = 'none';
                tbody.innerHTML = '';
                
                // Update header to show loading
                const headerEl = document.getElementById('all-symbols-header');
                if (headerEl) {
                    headerEl.textContent = `Loading data for ${selectedDate}...`;
                }
                
                // Fetch dashboard data with the selected date - show ALL symbols
                const dashboardData = await fetchDashboardData(selectedDate, true);
                
                // Hide loading state
                loadingState.style.display = 'none';
                
                if (dashboardData && dashboardData.portfolio_stocks) {
                    // Update the global data
                    originalData = dashboardData.portfolio_stocks || [];
                    
                    // Calculate summary from the dashboard data for this date
                    const summaryData = await fetchSummaryData(dashboardData);
                    
                    // Re-render the All Symbols table AND update summary cards
                    filterAndSort();
                    renderSummaryCards(summaryData);
                    
                    // Update header to show success
                    if (headerEl) {
                        headerEl.textContent = `${originalData.length} stocks for ${selectedDate}`;
                    }
                    
                    console.log(`✅ Updated All Symbols table and summary cards with ${originalData.length} stocks for ${selectedDate}`);
                } else {
                    // Show empty state if no data for selected date
                    originalData = [];
                    filterAndSort();
                    renderSummaryCards(null); // Clear summary cards
                    
                    // Update header to show no data
                    if (headerEl) {
                        headerEl.textContent = `No data available for ${selectedDate}`;
                    }
                    
                    emptyState.style.display = 'block';
                    console.log(`⚠️ No data available for ${selectedDate}, showing empty table`);
                }
            } catch (error) {
                console.error('Error refreshing All Symbols for date:', error);
                // Hide loading state and show error
                document.getElementById('loading-state').style.display = 'none';
                document.getElementById('empty-state').style.display = 'block';
                
                const headerEl = document.getElementById('all-symbols-header');
                if (headerEl) {
                    headerEl.textContent = `Error loading data for ${selectedDate}`;
                }
            }
        }
        
        async function loadPortfolioForDate(date) {
            try {
                // Show loading state
                const loadingState = document.getElementById('my-portfolio-loading');
                const emptyState = document.getElementById('my-portfolio-empty');
                const tbody = document.getElementById('my-portfolio-tbody');
                loadingState.style.display = 'block';
                emptyState.style.display = 'none';
                tbody.innerHTML = '';

                const response = await fetch(`/api/portfolio/holdings?trade_date=${date}`);
                const data = await response.json();

                // Hide loading state
                loadingState.style.display = 'none';

                if (data.success) {
                    myPortfolioData = data.portfolio_data || [];
                    renderMyPortfolio(myPortfolioData);

                    // Update portfolio data info
                    const portfolioDataInfoEl = document.getElementById('portfolio-data-info');
                    if (portfolioDataInfoEl) {
                        if (data.data_dates) {
                            const dateDates = data.data_dates;
                            const differentDates = [];

                            if (dateDates.nvdr && dateDates.nvdr !== data.market_date) {
                                differentDates.push(`NVDR: ${dateDates.nvdr}`);
                            }
                            if (dateDates.short_sales) {
                                if (Array.isArray(dateDates.short_sales)) {
                                    // Multiple dates - show as range or "mixed"
                                    if (dateDates.short_sales.length === 2 && dateDates.short_sales.includes(data.market_date)) {
                                        const otherDate = dateDates.short_sales.find(d => d !== data.market_date);
                                        differentDates.push(`Short Sales: ${otherDate}-${data.market_date} (mixed)`);
                                    } else {
                                        differentDates.push(`Short Sales: ${dateDates.short_sales.join('-')} (mixed)`);
                                    }
                                } else if (dateDates.short_sales !== data.market_date) {
                                    differentDates.push(`Short Sales: ${dateDates.short_sales}`);
                                }
                            }

                            let infoText = `Data from ${data.market_date}`;
                            if (differentDates.length > 0) {
                                infoText += ` (${differentDates.join(', ')})`;
                            }
                            portfolioDataInfoEl.textContent = infoText;
                        } else if (data.market_date) {
                            portfolioDataInfoEl.textContent = `Data from ${data.market_date}`;
                        }
                    }

                    // Update main trade date display if we have market data
                    if (data.market_date) {
                        const tradeDateEl = document.getElementById('trade-date');
                        if (tradeDateEl) {
                            tradeDateEl.textContent = `Portfolio Date: ${date} | Market Data: ${data.market_date}`;
                        }
                    }
                } else {
                    myPortfolioData = [];
                    renderMyPortfolio(myPortfolioData);
                    emptyState.style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading portfolio (join):', error);
                document.getElementById('my-portfolio-loading').style.display = 'none';
                document.getElementById('my-portfolio-empty').style.display = 'block';
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Compute sticky offset for All Symbols header beneath the search bar
            function applyStickyOffset() {
                const search = document.getElementById('all-symbols-search');
                const container = document.querySelector('div.table-container.all-symbols');
                if (!search || !container) return;
                const extra = 8; // extra spacing below the search bar
                const offset = (search.offsetHeight || 80) + extra;
                container.style.setProperty('--sticky-offset', offset + 'px');
            }
            applyStickyOffset();
            window.addEventListener('resize', applyStickyOffset);
            // If fonts load later and change heights
            window.addEventListener('load', applyStickyOffset);
            // Sync horizontal scroll: move sticky header row with table body
            const tblContainer = document.querySelector('div.table-container.all-symbols');
            const hdrRow = document.getElementById('all-symbols-header-row');
            if (tblContainer && hdrRow) {
                tblContainer.addEventListener('scroll', () => {
                    hdrRow.style.transform = `translateX(${-tblContainer.scrollLeft}px)`;
                });
            }

            initDashboard();
            
            // Load available dates and set up date selector
            loadAvailableDates();
            
            // Date picker change handler
            document.getElementById('portfolio-date-picker').addEventListener('change', async (e) => {
                const selectedDate = e.target.value;
                currentPortfolioDate = selectedDate;
                
                // Update status based on availability
                updateDateStatus(selectedDate);
                
                // Refresh the All Symbols table first, then build portfolio from it
                await refreshAllSymbolsForDate(selectedDate);
                await loadPortfolioForDate(currentPortfolioDate);
            });

            // Search functionality
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.getElementById('search-clear');
            searchInput.addEventListener('input', (e) => {
                searchQuery = e.target.value;
                if (clearBtn) {
                    if (searchQuery && searchQuery.length > 0) clearBtn.classList.remove('hidden');
                    else clearBtn.classList.add('hidden');
                }
                filterAndSort();
            });
            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    searchInput.value = '';
                    searchQuery = '';
                    clearBtn.classList.add('hidden');
                    filterAndSort();
                    searchInput.focus();
                });
            }

            // SET index chart initialization moved to renderSetIndexChart() function called from initDashboard()

            // No portfolio-only toggle; portfolio has its own section

            // Sort functionality
            document.querySelectorAll('.sortable').forEach(el => {
                el.addEventListener('click', () => {
                    toggleSort(el.dataset.key);
                });
            });

            // Export functionality
            document.getElementById('export-btn').addEventListener('click', exportCSV);

            // Fresh scrape functionality with progress bar
            document.getElementById('refresh-btn').addEventListener('click', async (e) => {
                const btn = e.currentTarget;
                btn.disabled = true;
                btn.textContent = 'Running Scrapers...';
                const ctrl = startRefreshProgress();
                try {
                    document.getElementById('loading-state').style.display = 'block';
                    document.getElementById('empty-state').style.display = 'none';
                    document.getElementById('portfolio-tbody').innerHTML = '';
                    
                    // Run Python scrapers to get fresh data
                    console.log('🔄 Running fresh data scrape...');
                    const response = await fetch('/api/save-to-database', { method: 'POST' });
                    const result = await response.json();
                    
                    if (result.success) {
                        console.log('✅ Fresh scrape completed:', result.message);
                        // Wait a moment for database to be updated, then refresh display
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        await refreshFromDatabase();
                        // Also refresh timestamps specifically
                        try {
                            const timestampsData = await fetchDataTimestamps();
                            renderDataTimestamps(timestampsData);
                        } catch (error) {
                            console.error('Error refreshing timestamps after scrape:', error);
                        }
                        ctrl.finish(true);
                    } else {
                        console.error('❌ Fresh scrape failed:', result.message);
                        ctrl.finish(false);
                        alert(`Scrape failed: ${result.message}`);
                    }
                } catch (err) {
                    console.error('Fresh scrape failed:', err);
                    ctrl.finish(false);
                    alert('Scrape failed - check console for details');
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'Run Fresh Scrape';
                }
            });

            // Note: Database auto-updates on PC startup only


            // Refresh portfolio functionality (section hidden; guard for null)
            const refreshPortfolioBtn = document.getElementById('refresh-portfolio-btn');
            if (refreshPortfolioBtn) {
                refreshPortfolioBtn.addEventListener('click', () => {
                    refreshMyPortfolio();
                });
            }

            // Refresh timestamps functionality
            document.getElementById('refresh-timestamps-btn').addEventListener('click', async () => {
                const btn = document.getElementById('refresh-timestamps-btn');
                try {
                    btn.disabled = true;
                    btn.textContent = 'Refreshing…';
                    
                    const timestampsData = await fetchDataTimestamps();
                    renderDataTimestamps(timestampsData);
                    
                } catch (error) {
                    console.error('Error refreshing timestamps:', error);
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'Refresh';
                }
            });

            // Refresh SET index functionality
            document.getElementById('refresh-index-btn').addEventListener('click', async () => {
                const btn = document.getElementById('refresh-index-btn');
                const loadingState = document.getElementById('set-index-loading');
                const tbody = document.getElementById('set-index-tbody');
                
                try {
                    btn.disabled = true;
                    btn.textContent = 'Refreshing…';
                    loadingState.style.display = 'block';
                    tbody.innerHTML = '';

                    const setIndexData = await fetchSetIndexData();
                    renderSetIndex(setIndexData);

                    // Refresh chart and meta too
                    try {
                        const res = await fetch('/api/series/set-index');
                        const data = await res.json();
                        const latest = data.latest || {};
                        const chgClass = latest.change > 0 ? 'text-green-600' : (latest.change < 0 ? 'text-red-600' : '');
                        const meta = document.getElementById('set-latest-meta');
                        if (meta && latest && latest.close != null) {
                            meta.textContent = `${latest.date} • Close ${latest.close} (${latest.change > 0 ? '+' : ''}${latest.change} / ${latest.change_percent}%)`;
                            meta.className = `text-xs ${chgClass.replace('600','700')} opacity-80`;
                        }
                        if (window.Chart && document.getElementById('setChart')) {
                            const container = document.getElementById('setChart');
                            try {
                                // Clear container and create canvas
                                container.innerHTML = '<canvas id="setChartCanvas"></canvas>';
                                const canvas = document.getElementById('setChartCanvas');
                                canvas.width = container.clientWidth || 800;
                                canvas.height = container.clientHeight || 400;
                                
                                // Prepare data for Chart.js
                                const chartData = {
                                    labels: data.series.map(item => item.time),
                                    datasets: [{
                                        label: 'SET Index',
                                        data: data.series.map(item => item.value),
                                        borderColor: '#1e40af',
                                        backgroundColor: 'rgba(30,64,175,0.1)',
                                        borderWidth: 2,
                                        fill: true,
                                        tension: 0.1,
                                        pointRadius: 0,
                                        pointHoverRadius: 0
                                    }]
                                };
                                
                                // Add range selector buttons above the chart
                                const rangeContainer = document.createElement('div');
                                rangeContainer.className = 'flex gap-1 mb-2 justify-center';
                                rangeContainer.innerHTML = `
                                    <button class="range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded" data-range="90">3M</button>
                                    <button class="range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded" data-range="365">1Y</button>
                                    <button class="range-btn px-3 py-1 text-sm bg-slate-100 hover:bg-slate-200 rounded" data-range="1825">5Y</button>
                                    <button class="range-btn px-3 py-1 text-sm bg-blue-500 text-white rounded" data-range="all">All</button>
                                `;
                                container.insertBefore(rangeContainer, canvas);
                                
                                const chart = new window.Chart(canvas, {
                                    type: 'line',
                                    data: chartData,
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: {
                                                display: false
                                            }
                                        },
                                        scales: {
                                            x: {
                                                type: 'time',
                                                time: {
                                                    parser: 'yyyy-MM-dd',
                                                    displayFormats: {
                                                        day: 'MMM dd',
                                                        month: 'MMM yyyy'
                                                    }
                                                },
                                                display: true,
                                                grid: {
                                                    color: '#eee'
                                                }
                                            },
                                            y: {
                                                display: true,
                                                grid: {
                                                    color: '#eee'
                                                }
                                            }
                                        }
                                    }
                                });

                                // Add range selector functionality
                                const allData = [...data.series];
                                let currentRange = 'all'; // Default to all data on first load

                                function filterDataByRange(days) {
                                    // Get the latest date from the data
                                    const latestDate = new Date(Math.max(...allData.map(item => new Date(item.time))));
                                    const cutoffDate = new Date(latestDate);
                                    
                                    if (days === 'all') {
                                        // Limit "All" to 5 years max for better visualization
                                        cutoffDate.setFullYear(cutoffDate.getFullYear() - 5);
                                    } else {
                                        cutoffDate.setDate(cutoffDate.getDate() - days);
                                    }
                                    
                                    return allData.filter(item => new Date(item.time) >= cutoffDate);
                                }

                                function updateChart(range) {
                                    const filteredData = filterDataByRange(range);
                                    chart.data.labels = filteredData.map(item => item.time);
                                    chart.data.datasets[0].data = filteredData.map(item => item.value);
                                    chart.update('none');
                                    
                                    // Update active button styling
                                    rangeContainer.querySelectorAll('.range-btn').forEach(btn => {
                                        if (btn.dataset.range == range) {
                                            btn.className = 'range-btn px-2 py-1 text-xs bg-blue-500 text-white rounded';
                                        } else {
                                            btn.className = 'range-btn px-2 py-1 text-xs bg-slate-100 hover:bg-slate-200 rounded';
                                        }
                                    });
                                }

                                // Add click handlers for range buttons
                                rangeContainer.addEventListener('click', (e) => {
                                    if (e.target.classList.contains('range-btn')) {
                                        const range = e.target.dataset.range;
                                        currentRange = range;
                                        updateChart(range);
                                    }
                                });

                                // Initialize with default range
                                updateChart(currentRange);
                                
                                
                            } catch (chartError) {
                                console.error('Chart.js refresh failed:', chartError);
                            }
                        }
                    } catch (e) { /* ignore chart refresh errors */ }
                } catch (error) {
                    console.error('Error refreshing SET index:', error);
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'Refresh';
                }
            });

        });

        // Auto-refresh functionality
        let autoRefreshInterval = null;
        let autoScraperStatus = 'stopped';

        // Check for data updates every 30 seconds
        async function checkForUpdates() {
            try {
                const response = await fetch('/api/data/check-updates');
                const data = await response.json();
                
                if (data.success && data.has_updates) {
                    console.log(`🔄 Data updated ${data.seconds_ago} seconds ago, refreshing...`);
                    
                    // Show notification
                    showNotification(`🔄 New data available! Refreshing dashboard...`, 'info');
                    
                    // Refresh all data
                    await refreshFromDatabase();
                    await fetchDataTimestamps();
                    await renderDataTimestamps(timestampsData);
                }
            } catch (error) {
                console.error('Error checking for updates:', error);
            }
        }

        // Auto-scraper controls
        async function startAutoScraper() {
            try {
                const response = await fetch('/api/auto-scraper/start', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    autoScraperStatus = 'running';
                    document.getElementById('auto-scraper-start-btn').classList.add('hidden');
                    document.getElementById('auto-scraper-stop-btn').classList.remove('hidden');
                    showNotification('🤖 Auto-scraper started! Data will update every 10 minutes.', 'success');
                    
                    // Start checking for updates
                    if (!autoRefreshInterval) {
                        autoRefreshInterval = setInterval(checkForUpdates, 30000); // Check every 30 seconds
                    }
                } else {
                    showNotification('❌ Failed to start auto-scraper', 'error');
                }
            } catch (error) {
                console.error('Error starting auto-scraper:', error);
                showNotification('❌ Error starting auto-scraper', 'error');
            }
        }

        async function stopAutoScraper() {
            try {
                const response = await fetch('/api/auto-scraper/stop', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    autoScraperStatus = 'stopped';
                    document.getElementById('auto-scraper-start-btn').classList.remove('hidden');
                    document.getElementById('auto-scraper-stop-btn').classList.add('hidden');
                    showNotification('🛑 Auto-scraper stopped', 'info');
                    
                    // Stop checking for updates
                    if (autoRefreshInterval) {
                        clearInterval(autoRefreshInterval);
                        autoRefreshInterval = null;
                    }
                } else {
                    showNotification('❌ Failed to stop auto-scraper', 'error');
                }
            } catch (error) {
                console.error('Error stopping auto-scraper:', error);
                showNotification('❌ Error stopping auto-scraper', 'error');
            }
        }

        async function checkAutoScraperStatus() {
            try {
                const response = await fetch('/api/auto-scraper/status');
                const data = await response.json();
                
                if (data.success) {
                    autoScraperStatus = data.status;
                    if (data.status === 'running') {
                        document.getElementById('auto-scraper-start-btn').classList.add('hidden');
                        document.getElementById('auto-scraper-stop-btn').classList.remove('hidden');
                        
                        // Start checking for updates if not already running
                        if (!autoRefreshInterval) {
                            autoRefreshInterval = setInterval(checkForUpdates, 30000);
                        }
                    } else {
                        document.getElementById('auto-scraper-start-btn').classList.remove('hidden');
                        document.getElementById('auto-scraper-stop-btn').classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Error checking auto-scraper status:', error);
            }
        }

        // Notification function
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 max-w-sm ${
                type === 'success' ? 'bg-green-500 text-white' :
                type === 'error' ? 'bg-red-500 text-white' :
                'bg-blue-500 text-white'
            }`;
            notification.textContent = message;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 5000);
        }

        // Event listeners for auto-scraper controls
        document.getElementById('auto-scraper-start-btn').addEventListener('click', startAutoScraper);
        document.getElementById('auto-scraper-stop-btn').addEventListener('click', stopAutoScraper);

        // Check auto-scraper status on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkAutoScraperStatus();
        });

    </script>
</body>
</html>
